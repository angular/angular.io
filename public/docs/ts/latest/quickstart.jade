include ../../../_includes/_util-fns
  
:marked
  Our QuickStart goal is to build and run a super-simple Angular 2 application in TypeScript.

  ## See It Run!

  Try this <a href="/resources/live-examples/quickstart/ts/plnkr.html" target="_blank">live example</a>
  which loads the sample app in <a href="http://plnkr.co/" title="Plunker" target="_blank">plunker</a>
  and displays a simple message:

figure.image-display
  img(src='/resources/images/devguide/quickstart/my-first-app.png' alt="Output of QuickStart app")
:marked
  Of course we don't build apps to run in plunker.
  The following steps establish a development environment for the documentation samples
  that also can be the foundation for our real world applications. At a high level, we will
  
  - set up the [development environment](#devenv)
  - write the app's Angular [root component](#component)
  - write [main.ts](#main) which tells Angular to display the root component
  - write the [host web page](#index) (`index.html`)

code-example(format='.', language='html').
  Click the glyph on the right to copy code to the clipboard  ⇨⇨⇨⇨⇨⇨⇨⇨⇨⇨

a(id="devenv")
.l-main-section
:marked
  ## Development Environment
  
  We need an application project folder,
  some configuration, and some JavaScript libraries.

  Create a **new project folder**
  
code-example(format="").
  mkdir angular2-quickstart
  cd    angular2-quickstart

:marked
  Add a **tsconfig.json** file to the project folder and copy/paste the following:
+makeJson('quickstart/ts/tsconfig.1.json', null, 'tsconfig.json')(format=".")

button(onclick='why("add-tsconfig")' class='button button-small') Why
p
#add-tsconfig(hidden)
  .l-sub-section
    :marked
      ### Configure TypeScript
      
      We must guide the TypeScript compiler with very specific settings.
      
      We explore the `tsconfig.json` in the 
      <a href="guide/typescript-configuration.html#tsconfig" target="_blank">TypeScript Configuration</a> chapter.

a(id="typings")
:marked
  Add a **typings.json** file to the project folder and copy/paste the following:
+makeJson('quickstart/ts/typings.1.json', null, 'typings.json')(format=".")

button(onclick='why("add-typings")' class='button button-small') Why
P
#add-typings(hidden)
  .l-sub-section
    :marked
      ### TypeScript Typings
      Many JavaScript libraries extend the JavaScript environment with features and syntax
      that the TypeScript compiler doesn't recognize natively. We teach it about these capabilities with
      <a href="http://www.typescriptlang.org/Handbook#writing-dts-files" target="_blank">TypeScript type definition files</a>
      &mdash; *d.ts files* &mdash; which we identify in a `typings.json` file.
      
      We go a little deeper into *typings* in the 
      <a href="guide/typescript-configuration.html#typings" target="_blank">TypeScript Configuration</a> chapter.

a(id="package-json")
:marked
  Add a **package.json** file to the project folder and copy/paste the following:
+makeJson('quickstart/ts/package.1.json', null, 'package.json')(format=".")  
button(onclick='why("add-package-json")' class='button button-small') Why
P
#add-package-json(hidden)
  .l-sub-section
    :marked
      ### Adding the libraries we need with *npm*
      Angular application developers rely on the  <a href="https://docs.npmjs.com/" target="_blank"><i>npm</i></a>
      package manager to acquire the libraries their apps require.
      
      Don't have npm?
      <a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" title="Installing Node.js and updating npm">Get it now</a>
      because we're going to use it now and repeatedly throughout this documentation.
        
      The Angular team recommends the starter-set of packages specified in the `dependencies` and `devDependencies`
      sections of this QuickStart
      <a href="https://docs.npmjs.com/files/package.json" target="_blank">package.json</a> file.

    +makeJson('quickstart/ts/package.1.json',{ paths: 'dependencies, devDependencies'}, 'package.json (dependencies)')(format=".") 
    :marked
      There are other possible package choices. 
      We're recommending this particular set that we know work well together. 
      Feel free to make substitutions later to suit your tastes and experience.

      A `package.json` has an optional **scripts** section where we can define helpful
      commands for development and build tasks. 
      We've included a number of such scripts in our suggested `package.json`:
    +makeJson('quickstart/ts/package.1.json',{ paths: 'scripts'}, 'package.json (scripts)')(format=".") 

    :marked
      We execute most npm scripts in the following way: `npm run` + *script-name*. 
      Some commands (such as `start` don't require the `run` keyword).
      
      Here's what these scripts do:
      
      * `npm start` - run the compiler and a server  at the same time, both in "watch mode"
      
      * `npm run tsc` - run the TypeScript compiler once
      
      * `npm run tsc:w` - run the TypeScript compiler in watch mode; 
      the process keeps running, awaiting changes to TypeScript files and re-compiling when it sees them.
      
      * `npm run lite` - run the <a href="https://www.npmjs.com/package/lite-server" target="_blank">lite-server</a>, 
      a light-weight, static file server, written and maintained by 
      <a href="http://johnpapa.net/" target="_blank">John Papa</a> 
      with excellent support for Angular apps that use routing.
      
      * `npm run typings` - runs the [*typings* tool](#typings)
      
      * `npm postinstall` - called by *npm* automatically *after* it successfully completes package installation.
      This script installs the [TypeScript definition files](#typings) this app requires.
      
    button(onclick='why("add-package-json","package-json")' class='button button-small') Close
      
:marked
  Open a terminal window (command window in Windows) and install these packages
  with the npm command:
code-example(format="").
  npm install

.alert.is-important
  :marked
    Scary <span style="color:red; font-weight: bold">error messages in red</span> may appear **during** install. 
    The install typically <a href="javascript:why('npm-errors')">recovers</a> from these errors and finishes successfully.
  #npm-errors(hidden)
    :marked
      #### *npm* errors and warnings
      
      All is well if there are no console messages starting with `npm ERR!` *at the end* of **npm install**. 
      There might be a few `npm WARN` messages along the way &mdash; and that is perfectly fine.
      
      We often see an `npm WARN` message after a series of `gyp ERR!` messages. 
      Ignore them. A package may try to re-compile itself using `node-gyp`.
      If the re-compile fails, the package recovers (typically with a pre-built version)
      and everything works.
      
      Just make sure there are no `npm ERR!` messages at the end of `npm install`.

:marked
  **We're all set.** Let's write some code.


a(id="component")
.l-main-section
:marked
  ## Our First Angular Component
  Let's create a super simple Angular component.
button(onclick='why("what-is-a-component")' class='button button-small') Why
P
#what-is-a-component(hidden)
  :marked
    The *Component* is the most fundamental of Angular concepts. 
    A component manages a view - a piece of the web page where we display information
    to the user and respond to user feedback.
    
    Technically, a component is a class that controls a view template.
    We'll write a lot of them as we build Angular apps. This is our first attempt
    so we'll keep it ridiculously simple.
    
:marked
  Create an `app` sub-folder and make it the current directory
code-example(format="").
  mkdir app
  cd    app

button(onclick='why("why-app-folder")' class='button button-small') Why
P
#why-app-folder(hidden)
  .l-sub-section
    :marked
      We like to keep our application code in a sub-folder off the root called `app/`.

a(id="app-component")
:marked
  Add a component file named **app.component.ts** and paste the following lines:
+makeExample('quickstart/ts/app/app.component.ts', null, 'app/app.component.ts')(format=".")

button(onclick='why("inside-app-component")' class='button button-small') Why
P
#inside-app-component(hidden)
  .l-sub-section
    :marked
      ### AppComponent is the root of the application
      
      Every Angular app has at least one component, conventionally named `AppComponent`.
      
      Components are the basic building blocks of Angular applications.
      A component controls a portion of the screen &mdash; a "view" &mdash; through its associated template.
      
      The template defines the visual appearance of the component with HTML markup.
      The markup is a combination of standard HTML and Angular notation.
      
      The template notation can identify other application components which have their own templates
      and these templates identify yet other components.
      In this way an Angular application becomes a tree of components.

    a(id="component-parts")
    :marked
      This QuickStart has only one, extremely simple component. 
      But it has the essential structure of every component we'll ever write:
      
      * One or more <a href="javascript: why('import')">import</a>
      statements to reference the things we need.
      
      * A <a href="javascript: why('decorator')">@Component decorator</a> 
      that tells Angular what template to use and how to create the component.
      
      * A <a href="javascript: why('class')">component class</a>
      that controls the appearance and behavior of a view through its template.
    P
    button(onclick="why('inside-app-component', 'app-component')" class="button button-small") Close      
    P
    #import(hidden)
      :marked
        ## Import

        Angular apps are modular. They consist of many files each dedicated to a purpose.
              
        Angular itself is modular. It is a collection of library modules
        each made up of several, related features that we'll use to build our application.
        
        When we need something from a module, we import it. 
        Here we import the Angular `Component` decorator function from the
        main Angular library module because we need it to define our component.
      +makeExample('quickstart/ts/app/app.component.ts', 'import', 'app/app.component.ts (import)')(format=".")
      P
      button(onclick="why('import', 'component-parts')" class="button button-small") Close
    P
    #decorator(hidden)
      :marked
        ### @Component decorator

        `Component` is a **decorator** function that takes a *metadata* object.
        The metadata tell Angular how to create and use this component.
        
        We apply this function to the component class 
        by prefixing the function with the **@** symbol and invoking it with the metadata object.
        just above the class:
      +makeExample('quickstart/ts/app/app.component.ts', 'metadata', 'app/app.component.ts (metadata)')(format=".")
      :marked
        This particular metadata object has two fields, a `selector` and a `template`.

        The **selector** specifies a simple CSS selector for an HTML element that represents the component.
        
        The element for this component is named `my-app`.
        Angular creates and displays an instance of our `AppComponent`
        wherever it encounters a `my-app` element in the host HTML.

        The **template** specifies the component's companion template.
        A template is an enhanced form of HTML that tells Angular how to render this component's view.
        
        Our template is a single line of HTML announcing "*My First Angular App*".
      P
      button(onclick="why('decorator', 'component-parts')" class="button button-small") Close
    P
    #class(hidden)
      :marked
        ## Component class
        At the bottom of the file is an empty, do-nothing class named `AppComponent`.
      +makeExample('quickstart/ts/app/app.component.ts', 'export', 'app/app.component.ts (class)')(format=".")
      :marked
        When we're ready to build a substantive application, 
        we can expand this class with properties and application logic. 
        Our `AppComponent` class is empty because we don't need it to do anything in this QuickStart.
        
        We **export** `AppComponent` so that we can **import** it elsewhere in our application,
        as we'll see when we create `main.ts`.
      P
      button(onclick="why('class', 'component-parts')" class="button button-small") Close

a(id="main")
.l-main-section
:marked
  ## Show it with *main.ts*
  Now we need something to tell Angular to load the root component
  
  Add a new file , `main.ts`, to the `app/` folder as follows:
+makeExample('quickstart/ts/app/main.ts', null, 'app/main.ts')(format=".")
button(onclick='why("inside-main")' class='button button-small') Why
P
#inside-main(hidden)
  .l-sub-section
    :marked
      We need two things to launch the application:

      1. Angular's browser `bootstrap` function
      1. The application root component that we just wrote.
      
      We import both. Then we call `bootstrap`, passing in the **root component type**, 
      `AppComponent`.

      <a href='javascript:why("main-details")'>Click</a> for a deeper understanding of these choices.
        
    #main-details(hidden)
      :marked
        ### Bootstrapping is platform-specific
        We import the `bootstrap` function from `angular2/platform/browser`,
        not `angular2/core`. There's a good reason.
        
        We only call "core" those capabilities that are the same across all platform targets.
        True, most Angular applications run only in a browser and we'll call the bootstrap function from
        this library most of the time. It's pretty "core" if we're always writing for a browser.
          
        But it is possible to load a component in a different environment. 

        We might load it on a mobile device with [Apache Cordova](https://cordova.apache.org/) or [NativeScript](https://www.nativescript.org/).

        We might wish to render the first page of our application on the server
        to improve launch performance or facilitate 
        [SEO](http://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf).

        These targets require a different kind of bootstrap function that we'd import from a different library.
      
        ### Why do we create a separate ***main.ts*** file?
        
        The *main.ts* file is tiny. This is just a QuickStart.
        We could have folded its few lines into the `app.component` file
        and spared ourselves some complexity.
        
        We didn't for what we believe are good reasons:
        1. Doing it right is easy
        1. Testability
        1. Reusability
        1. Separation of concerns
        1. We learned about import and export
        
        ### It's easy
        Sure it's an extra step and an extra file. How hard is that in the scheme of things?
        
        We'll see that a separate `main.ts` is beneficial for *most* apps 
        even if it isn't critical for the QuickStart.
        Let's develop good habits now while the cost is low.
        
        ### Testability
        We should be thinking about testability from the beginning
        even if we know we'll never test the QuickStart. 
        
        It is difficult to unit test a component when there is a call to `bootstrap` in the same file.
        As soon as we load the component file to test the component, 
        the `bootstrap` function tries to load the application in the browser.
        It throws an error because we're not expecting to run the entire application, 
        just test the component. 
        
        Relocating the `bootstrap` function to `main.ts` eliminates this spurious error
        and leaves us with a clean component module file.
        
        ### Reusability
        We refactor, rename, and relocate files as our application evolves.
        We can't do any of those things while the file calls `bootstrap`.
        We can't move it. 
        We can't reuse the component in another application. 
        We can't pre-render the component on the server for better performance.
        
        ### Separation of concerns
        A component's responsibility is to present and manage a view.
        
        Launching the application has nothing to do with view management.
        That's a separate concern. The friction we're encountering in testing and reuse
        stems from this unnecessary mix of responsibilities.
        
        ### Import/Export
        
        While writing a separate `main.ts` file we learned an essential Angular skill:
        how to export from one module and import into another. 
        We'll do a lot of that as we learn more Angular.
        
      button(onclick='why("main-details"); why("inside-main", "main")' class='button button-small') Close

a(id="index")
.l-main-section
:marked
  ## Add the `index.html`
  The `index.html` is the web page that hosts the application
  
  Navigate to the **project root folder**.
  
code-example(format="").
  cd ..
:marked
  Create an`index.html` file in this root folder and paste the following lines:
+makeExample('quickstart/ts/index.html', null, 'index.html')(format=".")

button(onclick='why("inside-index")' class='button button-small') Why
P
#inside-index(hidden)
  .l-sub-section
    :marked
      There are three noteworthy sections of HTML

      1. We load the JavaScript <a href='javascript:why("libraries")'>libraries</a> we need
      
      2. We configure the `system` function from <a href='javascript:why("systemjs")'>SystemJS</a> and ask it to import the
      `main` file we just wrote.
      
      3. We add the <a href='javascript:why("my-app")'>&lt;my-app&gt;</a> tag in the `<body>`. 
      **This is where our app lives!** 
    #libraries(hidden)
      :marked
        ### Libraries
        We loaded the following scripts
      +makeExample('quickstart/ts/index.html', 'libraries', 'index.html')(format=".")
      :marked
        We began with Internet Explorer polyfills. 
        IE requires polyfills to run
        an application that relies on ES2015 promises and dynamic module loading.
        Most applications need those capabilities and most applications
        should run in Internet Explorer.

        Next are the polyfills for Angular2, `angular2-polyfills.js`.
        
        Then the <a href='javascript:why("systemjs")'>SystemJS</a> library for module loading,
        followed by the Reactive Extensions RxJS library.
      .l-sub-section
        :marked
          Our QuickStart doesn't use the Reactive Extensions 
          but any substantial application will want them
          when working with observables.
          We added the library here in QuickStart so we don't forget later.
      :marked
        Finally, we loaded the web development version of Angular 2 itself.

        We'll make different choices as we gain experience and
        become more concerned about production qualities such as
        load times and memory footprint.


    #systemjs(hidden)
      :marked
        ### SystemJS Configuration

        The QuickStart uses <a href="https://github.com/systemjs/systemjs" target="_blank">SystemJS</a>
         to load application and library modules. 
        There are alternatives that work just fine including the well-regarded 
        <a href="https://webpack.github.io/" target="_blank">webpack</a>.
        SystemJS happens to be a good choice but we want to be clear that it was a choice and not a preference.
        
        All module loaders require configuration and all loader configuration 
        becomes complicated rather quickly as soon as the file structure diversifies and
        we start thinking about building for production and performance.
        
        We suggest becoming well-versed in the loader of your choice.
        Learn more about SystemJS configuration
        <a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md" target="_blank">here</a>.

        With those cautions in mind, what are we doing in this QuickStart configuration?
      +makeExample('quickstart/ts/index.html', 'systemjs', 'index.html (System configuration)')(format=".")
      :marked
        The `packages` node tells SystemJS what to do when it sees a request for a 
        module from the `app/` folder. 
        
        Our QuickStart makes such requests when one of its
        application TypeScript files has an import statement like this:
      +makeExample('quickstart/ts/app/main.ts', 'app-component', 'main.ts (excerpt)')(format=".")
      :marked
        Notice that the module name (after `from`) does not mention a filename extension. 
        The `packages:` configuration tells SystemJS to default the extension to 'js', a JavaScript file.
        
        That makes sense because we transpile TypeScript to JavaScript
        <a href='javascript:why("transpile-in-browser")'><i>before</i> running the application</a>.
        
      #transpile-in-browser(hidden)
        .l-sub-section
          :marked
            #### Transpiling in the browser
            In the live example on plunker we transpile (AKA compile) to JavaScript in the browser
            on the fly. That's fine for a demo. That's not our preference for development or production.
            
            We recommend transpiling (AKA compiling) to JavaScript during a build phase 
            before running the application for several reasons including:
            
            * We see compiler warnings and errors that are hidden from us in the browser.
            
            * Pre-compilation simpifies the module loading process and 
            it's much easier to diagnose problem when this is a separate, external step.
              
            * Pre-compilation means a faster user experience because the browser doesn't waste time compiling.
            
            * We iterate development faster because we only re-compile changed files.
            We notice the difference as soon as the app grows beyond a handful of files.
            
            * Pre-compilation fits into a continuous integration process of build, test, deploy.
          
      :marked
        The `System.import` call tells SystemJS to import the `main` file 
        (`main.js` ... after transpiling `main.ts`, remember?).
        `main` is where we tell Angular to launch the application.
        We also catch and log launch errors to the console. 
        
        All other modules are loaded upon request
        either by an import statement or by Angular itself.
        
    #my-app(hidden)
      :marked
        ### *&lt;my-app&gt;*
        When Angular calls the `bootstrap` function in `main.ts`, it reads the `AppComponent`
        metadata, finds the `my-app` selector, locates an element tag named `my-app`,
        and loads our application between those tags.
        
        Something has to find and load our application modules. 
        We're using **SystemJS** to do that.
        There are other choices and we're not saying SystemJS is the best. 
        We like it and it works.


.l-main-section
:marked
  ## Compile and run!
  
  Open a terminal window and enter this command:
code-example(format="").
  npm start
:marked
  That command runs two parallel node processes
  1. The TypeScript compiler in watch mode
  1. A static server called **lite-server** that loads `index.html` in a browser
  and refreshes the browser when application files change

  In a few moments, a browser tab should open and display

figure.image-display
  img(src='/resources/images/devguide/quickstart/my-first-app.png' alt="Output of quickstart app")

:marked
  Congratulations!  We are in business.

  ### Make some changes
  
  Try changing the message to "My SECOND Angular 2 app".
  
  The TypeScript compiler and `lite-server` are watching.
  They should detect the change, recompile the TypeScript into JavaScript,
  refresh the browser, and display the revised message.

  It's a nifty way to develop an application!
  
  We close the terminal window when we're done to terminate both the compiler and the server.

.l-main-section
:marked
  ## Final structure
  Our final project folder structure looks like this:
.filetree
  .file angular2-quickstart
  .children
    .file app
    .children
      .file app.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json
:marked
  And here are the files:
+makeTabs(`
    quickstart/ts/app/app.component.ts,
    quickstart/ts/app/main.ts,
    quickstart/ts/index.html,
    quickstart/ts/package.1.json,
    quickstart/ts/tsconfig.1.json,
    quickstart/ts/typings.1.json
  `,null,
  `app/app.component.ts, app/main.ts, index.html,package.json, tsconfig.json, typings.json`)
:marked

.l-main-section
:marked
  ## Wrap Up
  Our first application doesn't do much. It's basically "Hello, World" for Angular 2.

  We kept it simple in our first pass: we wrote a little Angular component,
  we added some JavaScript libraries to `index.html`, and launched with a
  static file server. That's about all we'd expect to do for a "Hello, World" app.

  **We have greater ambitions.**

  The good news is that the overhead of setup is (mostly) behind us. 
  We'll probably only touch the `package.json` to update libraries.
  We'll likely open `index.html` only if we need to add a library or some css stylesheets.

  We're about to take the next step and build a small application that 
  demonstrates the great things we can build with Angular 2.

  Join us on the [Tour of Heroes Tutorial](./tutorial)!
