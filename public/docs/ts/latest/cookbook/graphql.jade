include ../_util-fns

<a id="top"></a>
:marked
  GraphQL is a network protocol, a query language for your API, and a runtime for fulfilling those queries with your existing data.

.l-sub-section
  :marked
    GraphQL is a replacement or enhancement for REST and can be used in conjunction with it.

:marked
  GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.


<a id="toc"></a>
:marked
  ## Contents

  - [What is GraphQL?](#what-is-graphql)

  - [The benefits of GraphQL with Angular](#benefits-of-graphql)

  - [How to use GraphQL in an Angular app with app demo:](#how-to)
    - [Installation](#installation)

    - [Performing a query](#querying)

    - [Performing a mutation](#mutation)

  - [Appendix: Setting up a GraphQL server](#server)

  - [Further resources](#resources)

  - [Full Example](#example)

:marked
  **See the <live-example name="heroes-graphql"></live-example>**.

.l-main-section
<a id="what-is-graphql"></a>
:marked
  ## What is GraphQL?

  GraphQL is an API query language, helping your Angular app:

  - Fetch exactly the information it needs from the server.
  - Add type safety to your API.
  - Merge multiple dependencies into one single response from the server.
  - Handle server data dependency in a component structure.

  Itâ€™s also important to understand that:

  - **GraphQL is not a data source**. The GraphQL runtime works on top of any data source&mdash;SQL,
  NoSql, REST, Queues, .NET servers, Java servers or any other technology or data source.
  - GraphQL solves the need of sending multiple requests for multiple resources to the server and
  then running complex joins on the client&mdash;without the need to create a custom endpoint like REST does.
  - The GraphQL specification also includes protocols for real-time push updates from the server to the client.

  See the official [GraphQL](http://graphql.org/) site for a more in-depth look.

.l-main-section
<a id="benefits-of-graphql"></a>
:marked
  ## The benefits of GraphQL with Angular

.l-sub-section
  :marked
    For a summary of this section, see [Faster modern apps with Angular and GraphQL](https://www.youtube.com/watch?v=Xx39bv-5ojA&t=1s) 
    presented by [Jeff Cross](https://twitter.com/jeffbcross) and [Uri Goldshtein](https://twitter.com/UriGoldshtein).

iframe(type='text/html' width='560' height='315'
    src='https://www.youtube.com/embed/Xx39bv-5ojA'
    frameborder='0')    

:marked
  ### Component based API

  Angular components are composable, reusable, and allow encapsulation of behaviour
  and state. So how does one keep these benefits when fetching data from the server?
  Without GraphQL, there are three possible solutions:

  1. Using the HTTP service inside components.
  2. Calling a service from a component.
  3. Fetching data at the parent component and passing it down the component tree.

  While these solutions are valid, they have their limitations.

  #### Using the HTTP service in the Component

  There are two potential issues with this approach:

  1. Multiple redundant requests; when you render multiple components,
  for example, through `ngFor` with many components, each sends its own
  HTTP call.
  2. Inconsistent data; if two components fetch the same data but in different requests,
  the data might change and not be consistent across the app.

a#http-heroes
:marked
  #### Using a service

  Consider the following service and component:

+makeExample('toh-6/ts/src/app/hero.service.ts', 'getHero','hero.service.ts (Fetch by Id)')
+makeExample('toh-6/ts/src/app/hero-detail.component.ts', 'service-fetch-by-id','hero-detail.component.ts (Fetch by Id)')

:marked
  There are two potential issues here.

  1. A dependency between the service and all of the components that use it
  make the component no longer reusable. If you change something in the service,
  it might break other components that use that service.
  2. There is a main, complex point to handle batching, caching, and join logic. 
  Because the logic is shared between components, the potential of things breaking increases.

:marked
  #### Fetching data at the parent component and passing it down the component tree

  Consider an example of the second possibility:

+makeExample('toh-4/ts/src/app/hero.ts','','Declare the API type')
+makeExample('toh-4/ts/src/app/hero-detail.component.ts','declaring-conponent-input','Declare the input')
+makeExample('toh-4/ts/src/app/app.component.ts','calling-component','Using from parent')

:marked
  This works until you change the API of the component, which means you need to change
  its parent components _all the way to the top_.
  Again, this creates a dependency. This time it is with the child component
  all the way up to the fetching component
  and _all the components in between_.

  #### Solution - Component based API


:marked
  Here, the data dependency is inside the component. The query reflects just 
  what the single component needs and is included as part of the 
  component or a wrapper component. That means that when the 
  data dependency changes, the component is the only thing 
  impacted. You don't have to touch any services or parent components.

:marked
  Now, a single component contains all of its own data dependency changes.

:marked
  The `watchQuery` function tells the Apollo Client what data 
  this component needs. The Apollo Client then returns the 
  necessary data to the component as an Observable.
  For example, adding an `age` field to the app is 
  simple because you only change the component (you cover 
  this syntax [later](#querying) in the cookbook) And then modify the template accordingly:

+makeExample('heroes-graphql/ts/src/app/hero-detail.component.1.ts','graphql-query-new-field','Adding an `age` field to the component')
+makeExample('heroes-graphql/ts/src/app/hero-detail.component.1.html','template-new-field','Adding an `age` field to the template')

:marked
  So far, you've seen how to fetch data with GraphQL for a component while 
  keeping the component isolated from the rest of the app.
  That solves the most time-consuming and bug provoking code 
  that one usually writes in order to fetch data from the server.
  You can also use GraphQL to improve efficiency.

:marked
  ### Network Performance

  The [Tour of Heroes HTTP guide](latest/tutorial/toh-pt6.html) 
  calls `getHeroes` to fetch all heroes and their information.

:marked
  That might work for simple cases but the problem here is that `getHeroes` might fetch
  more information than the app really needs for each hero.
  This approach also creates a dependency between the server endpoint and the UI
  component&mdash;if you change or limit the amount of information you send on the
  server, you might break the components that use that endpoint.

  The other approach would be to call `getHeroes`, get the ids of the heroes and call `getHero` for each id.
  That might result in _multiple requests to the server_ for one single render of the page.

  With a REST API, you _always have to choose between those two options_ and 
  their respective problems.

:marked
  With GraphQL, you just specify the dependency of each component and a 
  GraphQL client library, like the [Apollo Client](http://dev.apollodata.com/),
  to merge those into **one single network request**. GraphQL sends back the information
  in a single response, with exactly the information you need&mdash;no more, no
  less&mdash;in exactly the structure and shape you want the data to be with 
  no need to do complex joins or wait for responses.

.l-sub-section
  :marked
    You can work with the Apollo Client 
    while still keep your existing REST services in your Angular app 
    and migrate gradually from them.

:marked
  ### Typed API, tooling and auto documentation

  Just as TypeScript provides tooling to increase productivity and best practices,
  GraphQL provides a similar solution for working with APIs.

  Often, APIs are written by teams you don't have access to and
  can change without notice.

  With GraphQL, the schema is typed and shared between the client
  and the server. As a result, just as with Angular and TypeScript, 
  you get the same development experience when calling calling a remote 
  API&mdash;validation and autocompletion inside the IDE at development time.

.l-main-section
<a id="how-to"></a>
:marked
  ## How to use GraphQL in an Angular app

  This guide uses [Apollo Client](http://dev.apollodata.com/) as the GraphQL client for Angular.
  Apollo helps you query GraphQL and provides a caching layer 
  with common features you need for querying a server such as 
  caching, mutations, optimistic UI, real-time subscriptions, 
  pagination, server-side rendering, and prefetching.

.l-sub-section
  :marked
    This cookbook touches on the main points of using GraphQL with Angular. 
    The full documentation can be found on the [Apollo Client website](http://dev.apollodata.com/).

:marked
  The starting point for the app is the [Tour of Heroes tutorial](https://github.com/Urigo/quickstart/archive/graphql-start.zip) app at its end state.

  This guide shows you how to migrate that app from REST to GraphQL.

.l-main-section
<a id="installation"></a>
:marked
  ## Installation

  First, install Apollo Client and the integration libraries from npm:

code-example(language="sh" class="code-shell").
    npm install apollo-client apollo-angular graphql-tag --save

.l-sub-section
  :marked
    This example uses `system.js` so you need to also add the configuration to it.
    With other build systems, the following process will be different and maybe easier.

:marked
  Add the following configuration to your `systemjs.config.js` file under the `map` key:

+makeExample('heroes-graphql/ts/src/systemjs.config.extras.js', 'systemjs-apollo-client-map', 'under map: { (excerpt)')

:marked
  and the following configuration to your `systemjs.config.js` file under the `packages` key:

+makeExample('heroes-graphql/ts/src/systemjs.config.extras.js', 'systemjs-apollo-client-packages', 'under packages: { (excerpt)')  

:marked
  Next, initialize the client by creating a new file called `client.ts` and 
  pasting in the following code:

+makeExample('heroes-graphql/ts/src/app/client.1.ts', '', 'app/client.ts')
:marked
  So what's happening here?
  
  This is how to use the default initialization of Apollo which calls the `/graphql` endpoint.
  First, you import `ApolloClient`. then you create a constant for the new instance of the client, 
  and finally export it so that it is available to the app.

.l-sub-section
  :marked
    ### To use a different URI for the Apollo Client
    For this cookbook we would use the default `/graphql` endpoint,
    but it's good to know it is possible to change those settings.
    To change the [settings](http://dev.apollodata.com/core/apollo-client-api.html#ApolloClient\.constructor) 
    of `ApolloClient`, call its constructor with different parameters. 
    Go to the [Apollo documentation](http://dev.apollodata.com/angular2/initialization.html#creating-client) for further resources.

:marked
  Usually you need to query an existing server.
  The server for this guide is based on the [Tour of Heroes](ts/latest/tutorial/) app.
  The starter app already has an in-memory GraphQL server prepared. 
  
  Now all that's left is to connect the in-memory server to the Apollo Client configuration 
  by importing `networkInterface` and adding it to the `client` constant in `client.ts`.
+makeExample('heroes-graphql/ts/src/app/client.ts', '', 'client.ts')
.l-sub-section
  :marked
    In order to learn how to create the GraphQL server for this example, follow the instructions on 
    [Appendix: Setting up a GraphQL server](#server).

:marked
  After initializing the Apollo Client, import the `ApolloModule` and `getClient` 
  which you just configured in `client.ts` into the app's root module:
+makeExample('heroes-graphql/ts/src/app/app.module.ts', 'import-apollo', 'app.module.ts (excerpt)')

:marked
  Next, add `ApolloModule.forRoot(getClient)` to the `@NgModule` imports array. This 
  is an initialization function that accepts the Apollo configuration 
  you created earlier as an argument and creates a new Apollo instance for the app.

+makeExample('heroes-graphql/ts/src/app/app.module.ts', 'apollo-ngmodule', 'app.module.ts (excerpt)')

:marked
  Now Apollo is initialized and ready for use in the app. 

.l-main-section
<a id="querying"></a>
:marked
  ## Performing a query

  With GraphQL you query a schema, which is organized into types and fields,
  that represents the data you can query. 

  The schema begins with data types and fields followed by the specific queries 
  you can perform on the data. These are in turn followed by 
  mutations, which are _actions_ that you 
  can call on the server, similar to a POST request in REST.

  Here is the schema the Tour of Heroes server in the app use:

+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'graphql-schema', 'Tour of heroes schema')  

:marked
  Once you have a server, which is prepared already in this app, to start querying data, begin by importing `Apollo` into `heroes.component.ts`,
  and injecting it into the constructor:
+makeExample('heroes-graphql/ts/src/app/heroes.component.ts', 'import-apollo', 'heroes.component.ts (excerpt)')
+makeExample('heroes-graphql/ts/src/app/heroes.component.ts', 'inject-apollo', 'heroes.component.ts (excerpt)')
:marked
  Now that the schema is available to the app, the next step is querying it. 
  In the component, import `gql` from the `graphql-tag` library. 
  The `gql` function turns your query string to something `Apollo` 
  can accept and understand.

+makeExample('heroes-graphql/ts/src/app/heroes.component.ts', 'import-graphql-tag', 'heroes.component.ts')

:marked
  In order to specify the TypeScript type of the data that is recieved, import `ApolloQueryResult` from `apollo-client`:

+makeExample('heroes-graphql/ts/src/app/heroes.component.ts', 'import-apollo-query-result', 'import type')
  
:marked
  To query data with the Apollo Client, pass a GraphQL query with the 
  data and structure that you want to the `Apollo` `watchQuery` function. 
  The `Apollo` ` watchQuery` function returns the data from the 
  server in the form of an Observable.
  Replace the `getHeroes()` function with this one:

+makeExample('heroes-graphql/ts/src/app/heroes.component.ts', 'query-heroes', 'heroes.component.ts')

:marked
  For more information on GraphQL queries, see the GraphQL documentation on 
  [Queries and Mutations](http://graphql.org/learn/queries/).
:marked
  Next, update the template so it displays the results of the query.
+makeExample('heroes-graphql/ts/src/app/heroes.component.1.html', 'render-heroes', 'heroes.component.html')

:marked
  At this point, if you have a running [GraphQL server](#server), the browser displays the 
  fetched data.

.l-main-section
<a id="mutation"></a>
:marked
  ## Performing a mutation

  In addition to fetching data using queries, GraphQL also makes it possible to change data through mutations.

  Mutations are identical to queries in syntax, the only difference being that you use the keyword `mutation` instead of `query` to indicate that you are performing writes to the backend.

.l-sub-section
  :marked
    You can look at a mutation as the equivalent of a POST request in REST.
:marked
  GraphQL mutations, like queries, are straightforward with minimal syntax. 
  Consider this example of a mutation:
code-example(language="json").
  mutation {
    addHero(heroName: "Russell Brand") {
      id
      name
    }
  }
:marked
  First, you declare that you're writing a mutation and then specify what it does. 
  To break it down, GraphQL mutations consist of two parts:
  1. The mutation name with arguments (`addHero`), which represents the actual 
  operation to be done on the server (just like calling a function).
  2. The fields you want back from the result of the mutation, which are sent back to the client. 
  In this example, they are `id` and `name`. This allows you to decide 
  which fields you get back from the server, 
  rather than the server dictating what's returned.

  The result of the above mutation might be:
code-example(language="json").
  {
    "data": {
      "addHero": {
        "id": "69",
        "name": "Russel Brand"
      }
    }
  }
.l-sub-section
  :marked
    For an in-depth look at mutation syntax, see the [Mutations 
    documentation](http://graphql.org/learn/queries/#mutations) 
    at [GraphQL.org](http://graphql.org).
:marked
  To use a mutation, first update the template with a function to add a hero:
+makeExample('heroes-graphql/ts/src/app/heroes.component.html', 'add', 'heroes.component.html')
:marked
  In the component class, create the `add()` function. It expects a name argument of type `string` 
  and is `void` because it returns nothing.  
+makeExample('heroes-graphql/ts/src/app/heroes.component.1.ts', 'add', 'heroes.component.ts')
:marked
  Now for the fun part. Inside of the `add()` function, add an `addHero` mutation 
  using the `apollo.mutate` function as follows:
+makeExample('heroes-graphql/ts/src/app/heroes.component.2.ts', 'add-mutation', 'heroes.component.ts')
:marked
  The mutation requires a variable and you pass it to the `mutate` function through the `variables` parameter.

  As mentioned above, with GraphQL mutations, you specify the result you want to get back from the server.

  Apollo's `mutate` function returns the result as an Observable.
  The Observable returns a `mutationResult` variable that is structured 
  like the `ApolloQueryResult` TypeScript type, where the generic `T` type is a `Hero` type:
code-example(language="json").
  type ApolloQueryResult&lt;T> = {
    data: T;
    loading: boolean;
    networkStatus: NetworkStatus;
  };
:marked
  If that looks familiar, it's because that's also how you reference the `mutationResult` variable in TypeScript.
  To access the hero data `mutationResult` returns, use dot notation to traverse `mutationResult` and assign it to a new hero object:
+makeExample('heroes-graphql/ts/src/app/heroes.component.ts', 'access-mutation-result', 'heroes.component.ts')
:marked
  Now that you have created the new object with the data, push it into the `heroes` array.

:marked
  Just like a query, the `mutate` function returns an Observable you can subscribe to 
  that handles the data you request.

  Now your existing heroes app can add a hero using GraphQL.
figure.image-display
  img(src='/resources/images/cookbooks/heroes-graphql/heroes- graphql-mutation.gif' alt="Heroes GraphQL Mutation")

.l-main-section
<a id="server"></a>
:marked
  ## Appendix: Setting up a GraphQL server

  This example shows how to run a GraphQL in the browser but running a GraphQL server on 
  Node.js or in the browser is very similar.
  
  If you don't have the option of running GraphQL on the server, 
  this method makes it possible to still use GraphQL in your app with the
  benefit of not needing to sync multiple REST requests and join logic 
  on the client.

.l-sub-section
  :marked
    To read more about how to run a full GraphQL backend, see the [Apollo Server documentation](http://dev.apollodata.com/tools/).
    Because the real, backend server is written in Isomorphic Javascript, 
    it is almost identical to the local server in this appendix.
    Everything you learn here applies to writing an actual GraphQL backend server.

    Additionally, there are a few GraphQL backend-as-a-service platforms available, 
    similar to Firebase, but based on the GraphQL API spec.
    For help on getting up and running, see [Scaphold](https://www.scaphold.io/) and [Graphcool](https://www.graph.cool/).

:marked
  In order to create a GraphQL schema, you need the `graphql-tools` library.
  It allows you to write a GraphQL schema as a string and make it executable. 
  In a terminal window, issue the following command:

.l-sub-section
  :marked
    This example uses `system.js` so you need to also add the configuration to it.
    With other build systems, or when running on Node, the following process will be different and 
    maybe easier.  

code-example(language="sh" class="code-shell").
    npm install graphql-tools --save

.l-sub-section
  :marked
    This example uses `system.js` so you need to also add the configuration to it.
    With other build systems, or when running on Node, the following process will be different and 
    maybe easier.

:marked
  Add the following configuration to your `systemjs.config.js` file under the `map` key:

+makeExample('heroes-graphql/ts/src/systemjs.config.extras.js', 'systemjs-graphql-server-map', 'under map: { (excerpt)')

:marked
  and the following configuration to your `systemjs.config.js` file under the `packages` key:

+makeExample('heroes-graphql/ts/src/systemjs.config.extras.js', 'systemjs-graphql-server-packages', 'under packages: { (excerpt)')  

:marked
  Next, create a file called `in-memory-graphql.ts` in the `app` directory 
  and paste in the following schema:

+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'graphql-schema', 'in-memory-graphql.ts')
:marked
  The schema starts with a represention of the model of data the server exposes. 
  Then the schema specifies what queries are allowed on that data, followed by 
  what mutations, or actions, clients are allowed to do on the server.
  The end of the schema provides the definitions as the root types the GraphQL server will expose.

.l-sub-section
  :marked
    While the schema includes the major points covered in this cookbook, 
    you can read more in the [GraphQL.org Introduction to GraphQL](http://graphql.org/learn/).
:marked
  Now, create your in-memory data:
+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'heroes-array', 'in-memory-graphql.ts (excerpt)')
:marked
  The next step is writing a server that _resolves_ 
  the queries from the client based on the schema. 
  Hence, the GraphQL server consists of _resolver 
  functions_ that correspond to the _types_ of the schema.

  In some server functions you use the `lodash` library so don't 
  forget to install them from npm and import them:
code-example(language="sh" class="code-shell").
    npm install lodash --save  
+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'import-lodash', 'in-memory-graphql.ts (imports)')

:marked
  To create the resolvers, copy the following code and add it to `in-memory-graphql.ts`.
+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'resolvers', 'in-memory-graphql.ts (excerpt)')

.l-sub-section
  :marked
    For the full explanation about how GraphQL resolvers work see
    [Execution](http://graphql.org/learn/execution/) on [GraphQL.org](http://graphql.org/).

:marked
  Notice that the server includes functions that correspond to each 
  type in the schema _and_ the mutations.

  This mechanism makes writing simple GraphQL servers straightforward&mdash;you simply 
  resolve a specific type of data. 
  This removes the coupling between the frontend and backend because you don't need to know the specific
  query the client makes to create the server implementation.

:marked
  Now, connect the schema to the resolvers with the `makeExecutableSchema` function from
  the [graphql-tools](http://dev.apollodata.com/tools/graphql-tools/index.html) library:
+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'import-graphql-tools', 'in-memory-graphql.ts (excerpt)')
+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'make-executable-schema', 'in-memory-graphql.ts (excerpt)')

:marked
  In the constant `schema`, `makeExecutableSchema` has two properties, 
  `typeDefs` and `resolvers`. Here, you define them with the `typeDefinitions` 
  and `resolveFunctions` that you created earlier in `in-memory-graphql.ts`. 
  This way, your GraphQL server knows where to look for definitions and resolvers.

:marked
  Now that you have an executable schema, execute it using the `graphql` 
  library and export it so you can use it with the Apollo Client. 
  First, `npm install`:
code-example(language="sh" class="code-shell").
    npm install graphql --save

:marked
  Next, add an import statement for `execute`.

+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'import-graphql', 'in-memory-graphql.ts (excerpt)')
:marked
  Now create a new `networkInterface` class and call it `InBrowserNetworkInterface`.

  This class has a `schema` property which it initializes in the constructor.

  Next, the `query` function takes as an argument the query request and executes 
  that query using the GraphQL `execute` function against the schema property.

  You send empty objects to the `rootValue` and `contextValue` arguments of the function with `{}` and `{}` respectively 
  and send the `variables` and `operationName` arguments that are related to the query request.
  
  Lastly, export the new `InBrowserNetworkInterface` class in order to import it to the Apollo Client.
+makeExample('heroes-graphql/ts/src/app/in-memory-graphql.ts', 'execute-and-export', 'in-memory-graphql.ts (excerpt)')
:marked
  Now all that's left is to connect the new in-memory server to the Apollo Client configuration 
  by importing `networkInterface` and adding it to the `client` constant in `client.ts`.
+makeExample('heroes-graphql/ts/src/app/client.ts', '', 'client.ts')
:marked
  That's it.  Now you can run your application as if you had a GraphQL server connected to it. 
  However, there is no persistance&mdash;everything is running in-memory in the browser, 
  so when you refresh the page, all changes will be lost.

  Now that you have a local server set up, you have some options:
  * You can store everything on the browser's local-storage using local-storage database libraries.
  * You can make the resolver functions call your server's existing REST endpoint.
  * You can start a separate Node GraphQL server and simply move the code into it for persistance.

.l-main-section
:marked
  ## Conclusion

  This cookbook covered:

  - What is GraphQL and why it can benefit Angular developers.
  - How to create a basic GraphQL query.
  - How to create a basic GraphQL mutation.
  - How to build a GraphQL server.
  - Resources to dive deeper.

.l-main-section
<a id="resources"></a>
:marked
  ## Further resources

  * [GraphQL.org](http://graphql.org/) is a great website, with the following sections
  (by the way, all the examples on the website are runing live, try to edit them in the browser while you reading it):
    * [Learn](http://graphql.org/learn/)
    * [Implementations in any language](http://graphql.org/code/)
    * [Community](http://graphql.org/community/)
  * [Apollo Developer resources](http://dev.apollodata.com/) - The [team](http://www.apollodata.com/) behind the Angular GraphQL client,
  there you will find a more advanced resources about:
    * [Handling updates from the server and managing the local store](http://dev.apollodata.com/angular2/receiving-updates.html)
    * [Authentication](http://dev.apollodata.com/angular2/auth.html)
    * [Pagination](http://dev.apollodata.com/angular2/pagination.html)
    * [Server-side rendering](http://dev.apollodata.com/angular2/server-side-rendering.html)
    * and more..
  * [Apollo Dev Blog](https://dev-blog.apollodata.com/) - The most popular GraphQL blog
  * [Apollo Client Developer Tools](https://dev-blog.apollodata.com/apollo-client-developer-tools-ff89181ebcf#.n5f3fhbg2) - GraphQL debugging tools for Apollo Client in the Chrome developer console  

.l-main-section
<a id="example"></a>
:marked
  ## Full Example

block file-summary
  +makeTabs(
    `heroes-graphql/ts/src/app/app.component.ts,
     heroes-graphql/ts/src/app/app.module.ts,
     heroes-graphql/ts/src/app/heroes.component.ts,
     heroes-graphql/ts/src/app/heroes.component.html,
     heroes-graphql/ts/src/app/heroes.component.css,
     heroes-graphql/ts/src/app/hero-detail.component.ts,
     heroes-graphql/ts/src/app/hero-detail.component.html,
     heroes-graphql/ts/src/app/in-memory-graphql.ts,
     heroes-graphql/ts/src/app/client.ts`,
    ',,,,,,,,',
    `app.comp...ts,
     app.mod...ts,
     heroes.comp...ts,
     heroes.comp...html,
     heroes.comp...css,
     hero-detail.comp...ts,
     hero-detail.comp...html,
     in-memory-graphql.ts,
     client.ts`
  )

  +makeTabs(
   `heroes-graphql/ts/src/app/app-routing.module.ts,
    heroes-graphql/ts/src/app/hero-search.component.ts,
    heroes-graphql/ts/src/app/hero-search.component.html,
    heroes-graphql/ts/src/app/hero-search.component.css`,
    null,
   `app-routing.modules.ts,
    hero-search.component.ts,
    hero-search.component.html,
    hero-search.component.css`
  )

:marked
  [Back to top](#top)
