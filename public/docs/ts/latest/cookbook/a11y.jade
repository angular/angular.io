include ../_util-fns

:marked
  Many people rely on assistive technologies to interact with the web, accessing visual
  content via screen readers or braille displays. Some rely exclusively on the keyboard for
  input, others adapt to motor impairment via pointing devices other than a mouse.

  This guide will show you how to design Angular components and applications that work well
  for all users.

:marked
  **Follow along in this [live example](/resources/live-examples/cb-a11y/ts/plnkr.html)**.


.l-main-section
<a id="toc"></a>
:marked
  ## Table of contents

  [Accessible form control labels](#form-control-labels)
  
  [Managing focus](#managing-focus)
  
  [Roles for custom component widgets](#component-roles)


.l-main-section
<a id="form-control-labels"></a>
:marked
  ## Accessible form control labels

  Native HTML elements already have accessibility support via the browser. Because Angular extends
  HTML and allows you to create your own elements, it's important to ensure that anything you add
  also works in an accessible way.

.l-sub-section
  :marked
    If there is already an HTML element that provides the function that you need, use that element
    instead of writing your own. You'll get all the built-in browser support for focus management,
    tabindex, etc. and have more time to think about your code. If you want to accept user text
    input, use the `input` element instead of constructing something new.

:marked
  Because assistive technologies can't rely on the visual appearance of a form component,
  any form component, or `form control` must be explicitly labeled to ensure that it's clear what
  its purpose is.

  We will discuss some ways to do this.

  ### Implicit labeling
  
  The most direct way to assign an accessible label to a form control is by `implicit
  labeling` with a `<label>` element. Like so:

code-example(language="html" escape="html").
  <label>label text
      <input>
  </label>

:marked
  We're applying a label to an `input`, but this could be replaced by any native HTML
  form control.

  However, there are some important caveats:

  - A `label` element can only describe a single form input element. You can't label multiple form
  fields with one label. If you need to label multiple fields, see _Explicit
   labeling_, below.
  - There are conventions with regard to text position for a `label` element. For `input`,
  `textarea` and `select`, label text precedes the element. For `checkbox` and `radiobutton`, the
  label should follow the element in the flow.

  Let's explore how we can use `implicit labeling` to decorate the commonly used native HTML form
  controls in our Angular&nbsp;2 components.



:marked
  #### Inputs and textareas

  Labeling an input:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-input-implicit')
  
:marked
  Labeling a textarea:
  
+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-textarea-implicit')  

:marked
  #### Checkboxes and radiobuttons

  Because of the many `input` fields making up a `checkbox group` or `radiobutton group`, in
  addition to labeling each input, the entire group also needs labeling. We do this by using
  `fieldset` and `legend`.

:marked
  Labeling checkboxes:
    
+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-checkboxes-implicit')

:marked
  Labeling radiobuttons:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-radiobuttons-implicit')
  
:marked
  #### Select lists

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-select-implicit')

:marked
  ### Explicit labeling

  In some situations, the `implicit labeling` syntax isn't appropriate. Maybe you need to write the
  input outside the label for positioning or styling purposes, or maybe your elements are already
  furnished with IDs.

  With `explicit labeling`, each HTML form element needs an `ID`, which is then connected via a
  `for / id` pair *[The `for` attribute of the label must match the `ID` of the element being
  labeled]* .

  Here's an example showing an `explicit label` with a `text input`. Although we don't show an
  example for each one, this works the same way for other form controls.

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html', 'cb-a11y-form-controls-input-explicit')

:marked
  ### Hidden labels

  Sometimes, there's a good reason to omit a visible label. For example, `search` fields don't
  typically have one. For users who can't see your page, or who rely on assistive technology, a
  label is still essential.

  There are two options for situations where you want a label to be hidden:

    - You can use an `explicitly labeled` input and hide the label with CSS, either by placing the label
     outside the visible area of the page, or by shrinking it to a non-visible size.
    - You can use `aria-label`, an `ARIA Property` that sets a label for use by
    assitive technologies such as screen readers.

  Why not just hide the label using the `display` css property? Hidden fields are also hidden to
  assistive technologies, and should only be used for content that is truly meant to be hidden
  from all users.

.callout.is-important
      header ARIA terminology confusion alert!
      :marked
        In `ARIA` we refer to the `aria-...` attributes as `ARIA States` or `ARIA Properties`.
        `ARIA Properties` are not true HTML element properties but decorating attributes
        referring to properties. Thus, in Angular&nbsp;2, when we refer to an `ARIA Property`, in
        the code you **must** use an Angular&nbsp;2 attribute binding. This is simply a terminology
        clash.

:marked
  Here's an example of a good visually hidden css style. We will not see it, but screen readers will
  correctly link to our input via the `for / id` linkup.
  
+makeExample('cb-a11y/ts/a11y.css', 'cb-a11y-form-controls-visually-hidden-style')
    
:marked
 Applying the style to a control to hide the label:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html', 'cb-a11y-form-controls-hidden-label-explicit')

:marked
 Or the `aria-label` alternative:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-hidden-label-aria')

:marked
  This `aria-label` attribute serves the same accessibility purpose as our `label` tags above and tells screen readers the label
  of the field.
  
.l-sub-section
  :marked
    So why not simply always use `aria-label`? This is because adding the `label` element not only provides the visual
    label, but linking a `label` to a `native form control` also means that clicking on the `label` will select the 
    `form control` itself. This assists users with motor disabilities by providing a larger clickable area, thereby also
    touching on another important area of accessibility.
    
:marked
  Let's have a look at a quick comparison between an inaccessible `input` with no label versus one
  labeled with `aria-label`, using the accessibility tools in the newest development version of
  `Chrome`.
  
  Here we see the information that assistive technologies will use when reading our field out:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/invisible-label-input-not-labeled.png" alt="Input with invisible label not labeled correctly")

:marked
  A user who relies on a screen reader hears: **Enter a value**.
  
  This isn't very helpful to the user wondering what value we're expecting. This is even worse if
  there's more than one input on the same page with the same placeholder.
  
  Now let's try the same input again, this time with an invisible label:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/invisible-label-input-labeled.png" alt="Input with invisible label labeled correctly")  
  
:marked
  It's immediately clear what this `input` field is all about and what to do with it!

:marked
  ### Labeling custom form controls

  What about custom form controls, where you can't rely on native HTML elements to provide
  accessibility?

  We can explicitly assign a role to tell assistive devices how to interpret custom controls with
  `aria-labelledby`.

.l-sub-section
  :marked
    The `for / id` function of the `label` element that we used above is only recognized when used
    with the native HTML form control elements such as `input` and `textarea`. To label anything
    else, like a `div` or a `custom element` we need to create this link by using `aria-labelledby`.

:marked
  We'll illustrate this by recreating the native `input` element with a component that makes use of
  `divs`. We're just doing this to make a point; creating an `input` out of `divs` is actually
   a terrible idea. Also note that as we are focusing on accessibility, our component is not
   production ready but only implements the basics of functionality to make it function as an `input`.

   The full implementation would become even larger and more complex before we can use it in an
   enterprise application. We hope that this illustrates further why native HTML elements should
   preferably be used.
    
:marked
  Our component:

+makeTabs('cb-a11y/ts/app/shared/a11y-custom-control.component.html,cb-a11y/ts/app/shared/a11y-custom-control.component.ts,cb-a11y/ts/app/shared/a11y-custom-control.component.css',
null, 'a11y-custom-control.component.html,a11y-custom-control.component.ts, a11y-custom-control.component.css')

.l-sub-section
  :marked
    You will see the `ng-content` tag in some examples. This is because we are using `Content
    Projection` to load content into the templates of our components.

:marked
  This can now be used in our HTML as follows:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-custom-control-usage')

:marked
  Let's have a look at what is rendered out. *For clarity sake, we omit the style attributes added by Angular&nbsp;2 
  for the component style.*:

code-example(language="html" escape="html" format="linenums").
  <a11y-custom-control class="ng-pristine ng-valid ng-untouched">
    <div class="form-group">
      <label id="60e9545d-8c5c-4c55-f171-e266c50479e9">
        Write in this labeled div:
      </label>
      <div aria-multiline="true" class="form-control edit-box" contenteditable=""
           role="textbox" aria-labelledby="60e9545d-8c5c-4c55-f171-e266c50479e9"></div>
    </div>
  </a11y-custom-control>

:marked
  The first thing that we should note is the `role` attribute. This is also part of `ARIA` and we use these when we need
  to tell assistive technologies that the semantic role of an HTML element has changed. The `div` element was certainly
  never specified as a textbox! Here we are using it as one, so our custom control needs the role of `textarea`.
  We will look at `ARIA Roles` in more detail later.
  
  Next we will look at the `aria-labelledby` attribute. As you can see, this has the `ID` of the `label` field. This
  is how we tell screen readers to use that specific `label` element to label our input control.

.l-sub-section
  :marked
    Besides the need to generate unique `IDs`, there is one more warning in using `aria-labelledby`. Even when using this
    with an actual `label` element, clicking the label will **NOT** focus the input as it does when used with native 
    HTML form control elements. Therefore, this construct will always be slightly inferior to the native approach,
    as you lose the accessibility gain the `label click` gives you.
    
:marked
  We also snuck in another `ARIA` property called `aria-multiline`. This is important, because an
  assistive device needs to understand whether our input accepts single or
  multiple lines of text. By using `aria-multiline`, we are able to tell the screen reader whether
  it is a single- or multiline field.

  This was a lot of work! Now that we've gone through the basic steps, we'll explore how `Content
  Projection` in Angular&nbsp;2 can be used to simplify the task of labeling custom components in a
  reusable way.
  
:marked
  ### Labeling options with Content Projection
  
  Because Angular&nbsp;2 components are reusable, we can design a component that can decorate any input:
  
+makeTabs('cb-a11y/ts/app/form-controls/a11y-input-wrapper.component.html,cb-a11y/ts/app/form-controls/a11y-input-wrapper.component.ts,cb-a11y/ts/app/form-controls/a11y-input-wrapper.component.css',
null, 'a11y-input-wrapper.component.html,a11y-input-wrapper.component.ts, a11y-input-wrapper.component.css')

:marked
  How do we use it? Like this:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-custom-control-wrapped-usage')  

:marked
  Let's quickly dive into the code.
  
  We used `Content Projection` with `multiple projection slots` to project our `input` and the `label` content into our component's
  template. This way we preserve direct access to and direct control of the `label` content as well
   as the `input`.
  
  We did not have to add any of the extra code of the previous component and our resultant decorated `input`
  control is fully accessible.

:marked
  ### Section summary
  
  In this section we looked at how we can give accessible labels to our native, as well as custom, form controls.
  
  We looked at `implicit labeling` versus `explicit labeling` and how `implicit labeling` can often save you 
  a lot of extra lines of code and trouble.
  
  We also saw that even when a control does not need a visual label, it still needs a label for those who 
  cannot see it and we looked at ways to hide these labels in an accessible way.
  
  Finally, we looked at how we can label even the most inaccessible of controls with `ARIA` and how we could use
  Angular&nbsp;2 components and content projection to ensure the accessibility of custom elements.
  
  Keep reading for more on accessibility in Angular&nbsp;2 or [go back to the table of contents](#toc)

.l-main-section
<a id="managing-focus"></a>
:marked
  ## Managing focus
  
  In addition to ensuring that our controls are labelled for assistive devices, we must
  consider how a user navigates to them. Many users don't have a mouse, or rely on the
  keyboard and assistive input devices when they navigate the web.

  Focus rules specify how a user navigates and interacts with a page, regardless of input device.
  There are two types of focus to consider:

  -`keyboard focus` defines an area of the page affected by the next keyboard action.
  -`reading focus` specifies where the screen reader will next start reading from.

.l-sub-section
 :marked
   In this section we will be looking primarily at `keyboard focus`. By correctly managing
   `keyboard focus`, the `reading focus` will usually also be correct.

:marked
    For keyboard navigation, users typically move their focus one focusable element forward using `Tab`
    or one element backward using `Shift+Tab`. Try this out in an application that you're
    familiar with to get a sense of how focus affects usability.
    
:marked
  ### Visual indication of current focus
  
  The `outline` style property defines the blue box that web browsers draw around the currently
  focused `element`.
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/standard-focus-outline.png" alt="Standard browser focus outline box")
  
:marked
  It clearly indicates where the current `keyboard focus` of the application lies. This is an
  essential piece of usability for someone who navigates without a mouse, as it is the only visual
  indication of where the current `keyboard focus` lies.

  Someone navigating a website with keyboard input alone cannot do so unless this is always clear.

.callout.is-important
  header The focus outline is a key accessibility feature
  :marked
    You may be tempted to remove the outline box with the style commands `outline:0` or
    `outline:none`. Doing so will make your site unusable for any sighted user who uses the keyboard or related assistive
    technologies.

:marked
  If you do need to change the outline style, ensure that you replace it with another style that shows up when the
  interactive element receives focus.
  
  Here's an example of a custom outline that changes the box to red:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/custom-focus-outline.png" alt="Standard browser focus outline box")  

:marked
  We accomplish this with the following style by taking a cue from `Twitter Bootstrap`:

+makeExample('cb-a11y/ts/a11y.css', 'cb-a11y-managing-focus-custom-outline')  

:marked
  Here we use the dangerous `outline:0`, **BUT** we then immediately give it another visual focus
  style.

:marked
  ### Focus flow

  If you tried out any `keyboard navigation` in the previous section, you would have noticed that the `keyboard focus` simply
  moves from one element to the next on the page. Our page layouts should support this to create a logical flow of
  focus throughout every page in our application.
  
.l-sub-section
  :marked
    Unless modified through script, the `normal flow of focus` will jump one focusable element up or down in the order that they
    appear in the `HTML DOM Tree`, regardless of visual page position. By ensuring that your HTML has a logical
    structure, you make sure that all users can navigate your pages correctly. Where you place the elements
    with `CSS` does not affect this order. We call this the `Separation of Content and Presentation`.
    
:marked
  We saw in the labeling section that we get a lot of standard accessibility functionality out of the box when we use
  `native form controls`, and here it is no different. **DO NOT** change the focus order with script unless
  it is for a very specific functional reason you cannot solve with the default flow, like focusing 
  on an error message the user needs to see. 
  
  Let's have a look at a basic example of separating content from presentation. We have a basic layout based on a list 
  of countries, asking for two pieces of information per country. It looks like this: 

figure.image-display
  img(src="/resources/images/cookbooks/a11y/focus-flow-clean.png" alt="Collection of inputs based on country list separated into columns per information type")

.l-sub-section
  :marked
    Note how we repeated the country name in both related `input labels`. Remember: **DO NOT** rely on visual context alone
    when labeling `HTML elements`. A person with a visual disability cannot see this context so you need to tell them, 
    through the screen reader, what the current element relates to.
    
:marked
  If we create this layout in the `HTML DOM Tree`, one column below the other, we end up with the following focus flow:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/focus-flow-bad.png" alt="Incorrect focus flow grouping taborder into columns")  

:marked
  The example's simplicity and the choice of labeling make this usable, but the flow is illogical. Generally,
  the user would want to think about one country at a time.
  
  A far superior focus flow moves the focus in the order that a reader would encounter it:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/focus-flow-good.png" alt="Correctly flowing focus by country")

:marked
  We do this by managing the focus flow through the `content` with HTML alone and changing the visual `presentation` with
  `CSS`. Just like that we are able to create the required flow with absolutely no scripting! 
  
  Here is the HTML:
  
+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html', 'cb-a11y-managing-focus-flow')

:marked
  ### Skiplinks
  
  For a sighted person who navigates the web using a mouse, it is very easy to skip sections of web pages.
  This could be because they are returning to a website they know very well, or because they can immediately see and interact
  with a specific section of interest.

  Similarly, we need to provide quick in-page links to help users who rely on assistive
  technology to navigate our page.

  These are called `skiplinks` and remain completely hidden until focused through `keyboard navigation`.

  Here's an example:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/skiplinks.png" alt="Correctly flowing focus by country")  

:marked
  You can, of course, give any styling you like, but here is how we made ours:
  
+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html','cb-a11y-managing-focus-skiplinks-links')  

:marked
  These links point to internal `IDs` and we build them with a function leveraging the `router`. *Please refer to the
  section on `routing` in the documentation for a more detailed explanation.*
  
  They are then rendered out as `internal links`:
  
code-example(language="html" escape="html" format="linenums").
  <a href="/managing-focus#focusflow">Go directly to focus flow</a>

:marked
  If the target of this link is not an interactive element, we can make that element focusable by adding
  `tabindex="-1"`. If we do not, it will not work in all browsers!
  
.l-sub-section
  :marked
    When we use `tabindex="-1"` we are allowing an element to 
    accept the current `keyboard focus`. However, this tells the browser to keep the element out of the normal
    `keyboard navigation` flow. It can only accept focus via internal links, clicks or script.

:marked
  The HTML of the target now looks like this:
  
+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html','cb-a11y-managing-focus-skiplinks-destination')    

:marked
  Finally we need some styling magic to make it all work by only showing focused links:

+makeExample('cb-a11y/ts/a11y.css', 'cb-a11y-managing-focus-skiplinks-style')

:marked
  Now that we know more about how browsers handle focus and what we can do to leverage it, it is time to look at what
  we can do inside our custom Angular&nbsp;2 components to keep them accessible.
  
:marked
  ### Interactive components should accept focus
  
  Unlike native interactive HTML elements, `custom interactive components` created with Angular&nbsp;2
  won't accept focus within the normal focus flow of the page during `keyboard navigation` unless
  we plan for it.
  
  This means that a native `button` element will accept focus, but a `button control` built as a 
  `custom element` from non-interactive HTML elements won't.
  
  So let's do exactly that, but first, another word of warning.
  
.l-sub-section
  :marked
    Again we need to stress that re-creating any `native HTML element` out of `custom elements` is **NOT** recommended, nor
    do we make any promises about the production readiness of our example. Our focus remains on accessibility and how
    we have the tools to make the most stubbornly inaccessible component accessible.
  
:marked
  There are rules governing which keyboard events should ideally be implemented per widget.
  For example, a regardless of how it is accessed, a `button` should accept focus, react to the
  mouse `click` event and react to the keyboard `enter` and `space` events.

  *You can read about these [Common Widget Design Patterns](https://www.w3
  .org/WAI/intro/accessibility.php) at the `W3C`.*

  Let's take a look at our custom button element:

+makeTabs('cb-a11y/ts/app/shared/a11y-custom-button.component.ts,cb-a11y/ts/app/shared/a11y-custom-button.component.html',
null, 'a11y-custom-button.component.ts,a11y-custom-button.component.html')  
  
:marked
  We manipulate the `Host` element of our component and now it can now be used like the standard
  `button` element:
  
+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html','cb-a11y-custom-button-usage') 

:marked
  Looking at the generated HTML we see:

code-example(language="html" escape="html" format="linenums").
  <a11y-custom-button class="btn btn-primary" role="button" tabindex="0">
    Do something...
  </a11y-custom-button>

:marked
  **Important**:  Note the `role` and `tabindex`. 
  
  The `ARIA role` of this element is `button`. It tells any assistive technologies that this element is
  a button, regardless of the original design of the HTML element. More information on this later.
  
  Setting the `tabindex` to `0` inserts the element in the default flow of`keyboard navigation` focus. This means that our
  element also becomes accessible via the keyboard!
  
.l-sub-section
  :marked
    **DO NOT** use a `tabindex` value of `1` or greater as this will change the default keyboard navigation.
  
:marked
  ### Internal focus management for components

  Programmatically setting focus within an app can introduce accessibility issues by interrupting
  or enforcing a particular flow. If you do set focus for the user, you must ensure that
  you do so in an accessible way.
  
  We'll illustrate how to do this by creating a `button` that shows an `alert`, then sets focus on the `alert`
  and then allows the user to close the error message with a `close button`.
  
+makeTabs('cb-a11y/ts/app/managing-focus/a11y-error-demo.component.html,cb-a11y/ts/app/managing-focus/a11y-error-demo.component.ts',
null, 'a11y-error-demo.component.html,a11y-error-demo.component.ts')

:marked
  We are setting focus on an `alert` that starts out hidden. As `hidden` and `disabled` elements cannot accept focus,
  we first need this element to become visible again. To give the browser time to apply this change we set our focus using
  a `timeout` function.
  
  Also note that we are using the `local template variable` to easily set focus right inside our
  template code.

  We also use `ARIA` to apply the role of `alert` and manage the `aria-hidden` property.

:marked
  ### Section summary
  
  In this section we saw how important `keyboard focus` is to make sure that many of our users are able to 
  navigate our web pages.
  
  We looked at displaying the current `keyboard focus` and how to build our component templates with a 
  natural flow of focus in mind.
  
  Finally we looked at what we can do to make sure that our own `components` can accept `focus` and how to 
  programmatically manage `focus` in our components.
  
  Keep reading to further explore accessibility in Angular&nbsp;2 or [go back to the table of contents](#toc)
  
.l-main-section
<a id="component-roles"></a>
:marked
  ## Roles for custom component widgets

  When creating a custom component widget, we can extend or change the behavior of an HTML element. To
   ensure accessibility, we must map our new component's behavior to an appropriate role in the [Accessibility Tree](https://www.w3.org/WAI/PF/aria-implementation/#intro_treetypes).

:marked
  ### How to apply an ARIA Role in Angular&nbsp;2
  
  We give an `ARIA Role` to an element by setting the value of the `role` attribute.

  When we write this directly in our HTML
  it is as simple as:
  
code-example(language="html" escape="html" format="linenums").
  <h2 role="alert">I am an alert.</h2>

.l-sub-section
  :marked
    Applying an `ARIA Role` overrides the implicit role of native elements.

:marked
  To see how we can use this in an Angular&nbsp;2 template, we turn to an old friend from our `labeling` section:

+makeExample('cb-a11y/ts/app/shared/a11y-custom-control.component.html')

:marked
  In Angular&nbsp;2 we refer to this new custom element as the `Host Element` of the component, because this is the element
  in our HTML that hosts our component's implementation.
  
  We can manipulate our `Host Element` through the `Host Property` of our component definition.
  
+makeExample('cb-a11y/ts/app/shared/a11y-custom-button.component.ts')  

:marked
  You can see that we apply the `role` of `button` to the host element. We can even check and see that this is rendered into the resultant
  `DOM` element:
  
code-example(language="html" escape="html" format="linenums").
  <a11y-custom-button class="btn btn-primary" role="button" tabindex="0">
    Do something...
  </a11y-custom-button>

:marked
  Now our browser, and any attached assistive technologies, know that `a11y-custom-button` is a `button`!

  
  Let's look at the two main sections of `roles` we can use to make our applications accessible. 

:marked
  ### ARIA landmark roles
  
  `Landmark Roles` refer to `navigational landmarks` or the regions of the
  page the user may want quick access to. Screen readers are also aware of these regions and this helps to give the user 
  a clearer *picture* of the page layout.
  
  These roles require some knowledge of the application structure and general layout.
  
  Visit the `W3C` to read more about the following [Landmark Roles](https://www.w3.org/TR/wai-aria/roles#landmark_roles):
  
  - application
  - banner
  - complementary
  - contentinfo
  - form
  - main
  - navigation
  - search

.callout.is-important
  header Avoid role="application"
  :marked
    The `application` role is often misused, and rarely necessary in an Angular app. It directs
    assistive technologies to change to a dual navigation/input mode, and captures keystrokes to do
    so. Unless you're building an especially complex interaction flow (e.g. a rich text document
    editor), and you're familiar with this role and its pitfalls, you should avoid its use.

:marked
  `HTML 5` provides native `semantic elements` that implicitly carry many of these roles and we recommend that you use these 
   when possible.
  
  Let's have a look at a high level HTML layout for a page using the `HTML 5 Semantic Elements`:

code-example(language="html" escape="html" format="linenums").
  <header role="banner">
    <!--Site focused header information.-->
  </header>
  <nav role="navigation">
    <!--Main site navigation-->
  </nav>
  <main role="main">
    <!--Contains the main page content-->
    <form role="search">
      <!--Search form-->
    </form>
    <form>
      <!--Normal form-->
    </form>
  </main>
  <aside role="complementary">
    <!--Supplementary site information-->
  </aside>
  <footer role="contentinfo">
    <!--Site information-->
  </footer>

:marked
   For landmark elements, we explicitly assign all roles (including native elements where a default
   exists) as some browsers do not implement native `semantic elements` correctly.

   When it is totally impossible to use these elements, e.g. when you need to support `HTML 4`,
   we can still create this structure in our HTML using `ARIA Roles`:
  
code-example(language="html" escape="html" format="linenums").
  <div role="banner">
    <!--Site focused header information.-->
  </div>
  <div role="navigation">
    <!--Main site navigation-->
  </div>
  <div role="main">
    <!--Contains the main page content-->
    <div role="search">
      <!--Search form-->
    </div>
    <div role="form">
      <!--Normal form-->
    </div>
  </div>
  <div role="complementary">
    <!--Supplementary site information-->
  </div>
  <div role="contentinfo">
    <!--Site information-->
  </div>

.l-sub-section
  :marked
    In the previous section we looked at `skiplinks`. These `landmarks` are great skiplink
    destinations.

:marked
  ### ARIA Roles: The widget roles
  
  The other section of `ARIA Roles` we will briefly look at is `Widget Roles`.
  
  The following roles are useful for standalone widgets:
  - alert
  - alertdialog
  - button
  - checkbox
  - dialog
  - gridcell
  - link
  - log
  - marquee
  - menuitem
  - menuitemcheckbox
  - menuitemradio
  - option
  - progressbar
  - radio
  - scrollbar
  - slider
  - spinbutton
  - status
  - tab
  - tabpanel
  - textbox
  - timer
  - tooltip
  - treeitem
  
  There is also a set of roles for `composite widgets`, i.e. widgets built from other widgets.
  - combobox
  - grid
  - listbox
  - menu
  - menubar
  - radiogroup
  - tablist
  - tree
  - treegrid

.l-sub-section
  :marked
    The names of these widget roles are self-explanatory. Visit the `W3C` to read more about
    [Widget Roles](https://www.w3.org/TR/wai-aria/roles#widget_roles)

:marked
  ### Section summary
  
  In this section we looked at how we tell the browser what type of `custom widget component` we are making. We also
  saw how we can override the role of a native HTML element.
  
  We saw that Angular&nbsp;2 makes applying a `role` to our `custom elements` easy by using
  the `Host Element`.
  
  Finally, we had a look at the most interesting `ARIA Roles` for us as Angular&nbsp;2 developers.
  
  [Go back to the table of contents](#toc)
  
