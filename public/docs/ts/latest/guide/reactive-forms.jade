include ../_util-fns

:marked
  Reactive forms allow explicit control over FormControls, FormArrays, and FormGroups.

.l-main-section
a#toc
:marked
  ## Contents

  - [Setup](#setup)
  - [Create a _reactive forms_ component](#create-comp)
  - [Create the template](#create-template)
  - [Import the _ReactiveFormsModule_](#import)
  - [Update the app to use the form component](#update)
  - [Intro to _FormBuilder_](#formbuilder)
  - [Grouping _FormControls_](#grouping)
  - [Inspecting form properties](#properties)
  - [Setting data using _patchValue_ and _setValue_](#set-data)
  - [Use _FormArray_ to add groups dynamically](#form-array)


  Run the <live-example></live-example>.

a#setup
:marked
  ## Setup
  Create a new project folder (`hero-signups`) and follow the steps in [QuickStart](../quickstart.html).

include ../_quickstart_repo

.l-main-section
a#create-comp
:marked
  ## Create a _reactive forms_ component
  The app needs a place for the form. Make a new file called `hero-signup.component.ts` in the `app` directory. Import `Component` from `@angular/core` and `AbstractControl`, `FormGroup`, and `FormControl` from `@angular/forms`:

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'reactive-comp-imports-v1','app/hero-signup.component.ts')(format=".")

:marked
  Here’s what each of them do:

  - `Component`: Angular’s component decorator.

  - `AbstractControl`: The base class for `FormArray`, `FormControl`, and `FormGroup`. It’s in charge of some of their shared behavior. You won’t have to instantiate it directly.

  - `FormControl`: Allows you to instantiate individual **FormControls**. Also tracks the value and validity of an individual `FormControl`.

  - `FormGroup`: Allows you to group **FormControls**, **FormArrays**, and other **FormGroups**.

  Below the import statements, use the `@Component` decorator to provide metadata to Angular:

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'reactive-comp-metadata-v1','app/hero-signup.component.ts (excerpt)')(format=".")

:marked
  The first line, `moduleId: module.id` lets you use [relative paths](./cookbook/component-relative-paths.html). The `selector` tells Angular where to render the form. And the `templateUrl` is the location of the HTML, or the contents of the form.

  Next, create the component class with a simple form model by exporting a class called `ReactiveFormComponent`, which will hold  the form model. The class name, `ReactiveFormComponent`, is arbitrary. You can name it whatever you like.

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'reactive-comp-class-v1','app/hero-signup.component.ts (excerpt)')(format=".")

:marked
  Inside the `FormGroup` called `form`, each `new FormControl()` instantiates a `FormControl` for the form. This way is repetitive, but it helps illustrate an important point later.

  The form model is only half of a reactive form. In order to make it available to the user, the app needs a template.

.l-main-section
a#create-template
:marked
  ## Create the template
  Now create `hero-signup.component.html` with the following code and save it in the `app` directory.

+makeExample('hero-signups/ts/app/hero-signup.component.1.html', 'html-begin','app/hero-signup.component.html')(format=".")

:marked
  On the `<form>` tag, `novalidate` prevents the browser from attempting any native validations and `[formGroup]="form"` lets Angular know that this is the form you’re referring to in the component class.

.l-sub-section
  :marked
    Disregard the bootstrap `form-group` and `form-control` _css_ classes. They are there to help with styling the project and in no way impact the logic of the form.

a#import
:marked
  ## Import the _ReactiveFormsModule_

:marked
  Your reactive form component template uses directives from the `ReactiveFormsModule` in the `@angular/forms` library
  so you must add it to the `imports` array of the application module that declares your reactive forms component.
  That will be the `AppModule` in this case.

  Do it in two steps:
  1. Use a JavaScript `import` statement to access the `ReactiveFormsModule`.
  1. Add it to the `AppModule`'s `imports` list.

+makeExample('hero-signups/ts/app/app.module.ts', 'app-module','app/app.module.ts (excerpt)')(format=".")

:marked
  Add one more quick step while in the file and add the `ReactiveFormComponent` you just made to the declarations array.


.l-main-section
a#update
:marked
  ## Update the app to use the form component
  Now that `app.module.ts` knows about `ReactiveFormComponent` you can use it.

  The app needs a place to _display_ the form you created above. Make a file named `app.component.html` with the following and save it in the `app` directory:

+makeExample('hero-signups/ts/app/app.component.html', 'app-component-html','app/app.component.html')(format=".")

:marked
  The `<hero-signup>` element is from the `@Component` decorator in `hero-signup.component.ts`. It tells Angular where to render the form.

  Update `app.component.ts` by adding `moduleId: module.id` to the `@Component` decorator so you can use a [relative path](./cookbook/component-relative-paths.html) to get to the `templateUrl` which is the `app.component.html` file you just created.

+makeExample('hero-signups/ts/app/app.component.ts', '','app/app.component.ts')(format=".")

:marked
  It’s working but to give it some style, add bootstrap by putting this in the head of `index.html`:

+makeExample('hero-signups/ts/index.html', 'bootstrap','index.html')(format=".")

:marked
  If you’ve copied the code snippets above, you already have the styles because they contain bootstrap classes.

  Now that everything is wired up, you should have something like this in the browser:

figure.image-display
  img(src="/resources/images/devguide/hero-signups/hero-signup.png" width="400px" alt="Basic reactive form")

:marked
  Great! You have the basics all set up, but in real life apps, forms can get big fast. The way the component class is currently creating **FormControls** doesn’t lend itself to ease of maintenance. `FormBuilder` helps you solve the problem.


.l-main-section
a#formbuilder
:marked
  ## Introduction to _FormBuilder_
  `FormBuilder` is a class that helps reduce repetition and clutter by doing some of the heavy lifting behind the scenes. To use `FormBuilder`, first, make sure you import it into `hero-signup.component.ts` by adding it to the current statement that imports `AbstractControl`, `FormControl`, and `FormGroup`.

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'reactive-comp-imports-addon','app/hero-signup.component.ts (excerpt)')(format=".")

:marked
  To take advantage of `FormBuilder`, `ReactiveFormComponent` needs refactoring. In the component class, let Angular know that `form` is of type `FormGroup`. Then use the constructor method and inject `FormBuilder` with `constructor(public fb: FormBuilder)`. Inside the constructor, you can use `FormBuilder` to set the `form` as a `FormBuilder` group which lets you instantiate the **FormControls** by simply using the `formControlName` and in this case, an empty value. In this way, `FormBuilder` instantiates each `FormControl` for you, reducing repetitive code. Now, you don't have to use `new` over and over.

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'class-refactor','app/hero-signup.component.ts (excerpt)')(format=".")

:marked
  This form looks great, but are the model and template talking? To inspect what’s going on, add this after the closing form tag in hero-signups.component.html:

+makeExample('hero-signups/ts/app/hero-signup.component.html', 'form-value-json','app/hero-signup.component.html')(format=".")

:marked
  This outputs the value of the form in JSON in the browser.

figure.image-display
  img(src="/resources/images/devguide/hero-signups/json-output1.png" width="400px" alt="JSON output")

:marked
  Type a value into any of the inputs to see the value update dynamically.

  This structure is ok for a small form, but what if you need to add a lot more inputs? Even adding an address could double the size of your form. If you’re suddenly managing lots of individual **FormControls**, you need a way to organize them.


.l-main-section
a#grouping
:marked
  ## Grouping FormControls
  In the component class add some address FormControls as below.

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'add-form-controls','app/hero-signup.component.ts (excerpt)')(format=".")

:marked
  Then add corresponding markup in `hero-signup.component.html` within the form element.

+makeExample('hero-signups/ts/app/hero-signup.component.1.html', 'add-controls','app/hero-signup.component.html (excerpt)')(format=".")

:marked
  The form is getting bigger, and in order to keep it maintainable you can group related **FormControls** using `FormGroup`. **FormGroups** are collections of **FormControls** that are registered  by name. Here, the `**FormControls** are registered with the `formControlName` directive, as are the **FormControls** that are already in the form.


  `FormGroup` is a class, so you can create an instance and pass in child controls. In case you hadn’t noticed, it’s already in the component class. It is how you declare what the form itself is with `form: FormGroup;`. `FormBuilder` also uses it in `this.form = this._fb.group({})`. The `.group()` method uses the `FormGroup` class to make a new group using the arguments you pass in.

  In the form right now, the arguments passed into the `.group()` method are the `FormControl`s such as `first: '', last: ''`,  etc. This form needs more than just one big group. To make this form more manageable, you can group the address FormControls. Start by adding `address: this._fb.group({ })` to the constructor and moving the address related FormControls inside it like so:

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'add-group','app/hero-signup.component.ts (excerpt)')(format=".")

:marked
  You’ve changed the structure of the form model, so head on over to the template and wrap the address related **FormControls** in a div using the `formGroupName` directive. Pass it the name you gave it in the component class, `address`. This registers a `FormGroup` instance on the `Form` instance.

+makeExample('hero-signups/ts/app/hero-signup.component.1.html', 'form-group','app/hero-signup.component.html')(format=".")

:marked
  Now the JSON output in the browser shows that `FormBuilder` has created a `FormGroup` for `address` and it is returned as an object:

figure.image-display
  img(src="/resources/images/devguide/hero-signups/address-group.png" width="400px" alt="JSON output")

:marked
  Great! You’ve made a group and you can see that the template and the model are talking to one another by inspecting the form’s value, but you don’t always need the whole form at once. Sometimes you need to see what’s happening on one `FormControl`.

.l-main-section
a#properties
:marked
  ## Inspecting Form Properties
  A `FormControl` is just a class and if you create an instance, you can inspect its properties. That means that you can check to see exactly what’s happening with a given `FormControl`. For example, say you instantiate a new `formControl` (you don’t need to put this in your app):

code-example(format=".").
  const myControl = new FormControl();

:marked
  You can easily look at its properties:
style td, th {vertical-align: top}
table(width="100%")
  col(width="10%")
  col(width="90%")
  tr
    th Property
    th Description
  tr
    td <code>value</code>
    td
      :marked
         description
  tr
    td <code>status</code>
    td
      :marked
         description
  tr
    td <code>pristine</code>
    td
      :marked
         description
  tr
    td <code>value</code>
    td
      :marked
         description
  tr
    td <code>untouched</code>
    td
      :marked
         description                                    
:marked
  These are just a few examples to give you an idea of what's available. To read more about **WHERE SHOULD I LINK TO? THE API REF DOESN'T GO INTO THESE METHODS**

  You can inspect an individual `FormControl` in the demo, such as the one for First Name, by using the `.get()` method. If you're curious, add the following to the template after the `form.value | json` interpolation. It isn't necessary for this demo.

+makeExample('hero-signups/ts/app/hero-signup.component.1.html', 'inspecting','app/hero-signup.component.html')(format=".")

:marked
  To get data on a FormControl that’s in a FormGroup, use the same method, but with dot notation.

+makeExample('hero-signups/ts/app/hero-signup.component.1.html', 'get-inspect','app/hero-signup.component.html')(format=".")

:marked
  One reason for inspecting the properties of the form is to make sure users fill it out properly. To do that, the app needs validations. To read more about validating Angular forms, see [Form Validation](../cookbook/form-validation.html).


.l-main-section
a#set-data
:marked
  ## Setting data with patchValue and setValue
  You can set default data in the form using `patchValue` or `setValue`. The main difference between the two is that `setValue` requires that you pass in every control in the form where `patchValue` allows you to provide values as needed, specifying only the fields you want to provide values for.

  Another important difference is that `setValue` performs strict checks and if there’s a missing control or the arguments don’t match the group structure, it returns helpful errors. On the other hand, `patchValue` doesn’t return any errors.

  To use `patchValue`, add it to the constructor in the component class and pass in an object of key value pairs for the FormControls you want to give default values. Here, the argument is an object that provides values for the first and last name **FormControls**.

+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'patch-value','app/hero-signup.component.ts')(format=".")

:marked
  Here is the same approach but using `setValue`. Notice that you have to mirror the structure of the form model and provide a value for every single `FormControl`.


+makeExample('hero-signups/ts/app/hero-signup.component.1.ts', 'set-value','app/hero-signup.component.ts')(format=".")

:marked
  Notice that with `setValue`, you can give it an empty value as in the password and confirm **FormControls**.



.l-main-section
a#form-array
:marked
  ## Use _FormArray_ to add groups dynamically
  Say you want to give the user the option to add another address, and another, and another, ad infinitum. This is the perfect task for `FormArray`. First, make sure you imported it in `hero-signup.component.ts`.

  Next, you’ll need to refactor a little. In the component class, add an addresses property as type `FormArray`.

+makeExample('hero-signups/ts/app/hero-signup.component.ts', 'form-array-class','app/hero-signup.component.ts')(format=".")

:marked
  Next, set up `addresses` in the constructor and take out the current address group:

+makeExample('hero-signups/ts/app/hero-signup.component.ts', 'use-build-array','app/hero-signup.component.ts')(format=".")

:marked
  Since there isn’t a `buildArray()` function in the app, you need to create it. A little further down in the component class, outside of the constructor, add a `buildArray()` method:

+makeExample('hero-signups/ts/app/hero-signup.component.ts', 'build-array','app/hero-signup.component.ts')(format=".")

:marked
  The `buildArray()` method is set to type FormArray and using FormBuilder, creates an array called addresses. The contents of the array comes from `buildGroup()`. Add `buildGroup()` to the component class with the following:

+makeExample('hero-signups/ts/app/hero-signup.component.ts', 'build-group','app/hero-signup.component.ts')(format=".")

:marked
  The `buildGroup()` method is of type `FormGroup` and returns the address related **FormControls**.

  There’s one last thing to put into the component class and that’s the `add()` function which you’ll use in the template on an Add Address button.

+makeExample('hero-signups/ts/app/hero-signup.component.ts', 'add-group','app/hero-signup.component.ts')(format=".")

:marked
  As you know, the template needs some work to take advantage of all these changes in the component class. First, change `formGroupName` to `formArrayName` and the name from address to addresses.

  Then, wrap the address **FormControls** in a div and use the *ngFor directive to create a `FormGroup` for every address. The next part, `let i=index" [formGroupName]="i"`, helps the app keep track of the index. Because it is an array, each `FormGroup` will have an index, rather than a name.

  Be sure to add the add button before the addresses closing div.

+makeExample('hero-signups/ts/app/hero-signup.component.html', 'array-group','app/hero-signup.component.html')(format=".")

:marked
  Now the browser shows addresses as an array:

figure.image-display
  img(src="/resources/images/devguide/hero-signups/addresses-array.png" width="400px" alt="JSON output of addresses array")

:marked
  If you click the Add Another Secret Lair button, you’ll see a new object pushed by the `add()` method to the addresses array containing the address **FormControls**. Ta-dah!!!

.l-main-section
:marked
  ## Conclusion

  This page covered:

  - How to create a reactive form and its corresponding template.
  - How to make your form component available to the app.
  - How to use `FormBuilder` to simplify coding a reactive form.
  - Grouping **FormControls**.
  - Inspecting `FormControl` properties.
  - Setting data with `patchValue` and `setValue`.
  - Adding groups dynamically with `FormArray`.

  You can download the complete source from the <live-example></live-example>.
