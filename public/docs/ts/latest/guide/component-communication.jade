include ../../../../_includes/_util-fns

:marked
  ## Component Communication

  Generally, an Angular app is a tree of components &mdash; with the bootstrapped component in its root. Thinking of an app's 
  structure as a tree, there are components that are in the same branch of the component tree &mdash; these form parent and child hierarchies
  &mdash;, and components in different branches &mdash; they are not directly related. Evidently, components need to communicate with each other
  to carry out the tasks the app is created for.
  
  As we already learned, _component_ is a pivotal concept of Angular, and it was designed with _inter-component communication_ in mind.
  We can think of the following information flows:
  * from a parent to its children
  * from a child to its parent
  * among unrelated, completely decoupled components
  
  In this chapter, we learn five frequently used Angular mechanisms and techniques available for inter-component communication.
  We also get acquainted with the tradeoffs of each mechanism, and understand the scenarios best suited for using a particular method of communication.
  Before diving deeply into the details, here is a short overview of these techniques:
  
  __#1: Parent to child communication with input property binding__
  
  The value of the `aHero` local variable of the parent is bound to the `hero` input property of the child. `hero` is updated every time when `aHero` changes:
  
+makeExample('component-communication/ts/app/invite-heroes/job-board-template.html', 'input-binding')
  
:marked
  Angular allows us to catch when an input property value of the child changes, and we can apply our own logic to respond to a particular change.
  
  [Jump to details](#-1-parent-to-child-communication-with-input-property-binding)

:marked
  __#2: Child to parent communication with event emitting__
  
  When a child needs to communicate with its parent, it can emit an event. The parent can define its own event handler method that responds
  to the child's event:

+makeExample('component-communication/ts/app/take-job-event/job-board-template.html', 'event-binding', null, {pnk: /(onJobTaken)/g} )
  
:marked
  Here, any time the child raises its `onJobTaken` event, the parent's `heroTakesJob()` method is called with the event argument 
  &mdash; `$event` &mdash; the child provides.
  
  [Jump to details](#-2-child-to-parent-communication-with-event-emitting)

  __#3: Duplex parent/child communication through a service object__
  
  Parent and child components share their responsibilities, including UI logic and others. They can delegate the shared state management
  to a service. Instead of talking directly with each other, both the parent and the child can communicate about that state through
  the service.
  
code-example(format="linenums" language="javascript").
  @Injectable()
  export class JobService {
    // ...
  }
  
:marked
  This service is injected into the parent and child components via Angular dependency injection (via component constructors):

code-example(format="linenums" language="javascript").
  @Component({
    selector: 'hero-job-board',
    template: `
      &lt;hero-panel *ngFor='#aHero of invitedHeroes'&gt;
      &lt;/hero-panel&gt;
    `,
    providers: [JobService]
  })
  export class HeroJobBoard {
    constructor(private jobService: JobService){
      // ...
    }
    // ...
  }
  @Component({
    selector: 'hero-panel'
    // ...
  })
  export class HeroPanel {
    constructor(private jobService: JobService){
      // ...
    }
    // ...
  }

:marked
  Both component types can access the service instance injected into the constructor. The dependency injection mechanism takes care 
  that the parent component instance and its children share a single instance of `JobService`.
  
  [Jump to details](#-3-duplex-parent-child-communication-through-a-service-object)

  ### The Hero Job Board sample
  
  In this chapter, we build a sample application that help us involve our heroes in actions when we really need their help.
  In this app, users can act on behalf of the person in need, and also on behalf of each hero. The basic workflow is the following:
  1. The person in need invites heroes to listen to job requests.
  1. When there's a decent job that requires superpower, the person in need announces a job request that is received by all heroes.
  1. Heroes can opt to undertake the job.
  1. When having received applications for the job, the person in need assigns the job to the one of the responding heroes.
  1. The assigned hero is notified about winning the job, the others receive a message about losing the opportunity.
  
  Here is a screenshot of our complete application:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/app-ui-snapshot.png" alt="UI in action")
  
:marked
  ### Live Example
  
  The application is available as a live example. In this app we are implementing Hero Job board scenarios, each of them
  illustrating one of the aforementioned techniques. A few scenario covers the entire workflow, while others implement only a 
  few steps.
  
  We use the router to make it easy to hop among the illustrations. Each scenario we present has a link in the headline of the app.
  When treating a specific technique, we name the link that leads to the corresponding sample.
  
  [Live Example](/resources/live-examples/component-communication/ts/plnkr.html)
  
  Let's start, and dive into the details!
  
  ## #1: Parent to child communication with input property binding
  
  Angular allows components to declare _data-bound input properties_. These are like regular component, but the value of an 
  input property takes its value from the expression bound to it. The framework automatically updates data-bound input properties
  during change detection.
  
  This is a _one-way binding_. As the source value changes, the destination property of the component changes, too. However, 
  when we change the value of the input property in the child, the property's value does not flow back to the parent.
  
  Input data binding can be used to pass data from a parent component to a single child, to all children, or only to a set of the children.
  As its name suggests, we can pass only data values: this method is not suitable for sending messages that can be represented only
  with method calls. This mechanism does not allow passing data from a child component to its parent.
  
  ### Establish an input property binding
  
  To create an input property binding, we need to carry out these steps:
  1. Adding an input property to the child component (apply the `@Input()` decorator on the particular property)
  1. Using this property with the _input binding syntax_ in the parent template to bind it to an expression
  
  The Hero Job Board application uses input data binding to pass the information about an invited hero from `HeroJobBoard` (parent) to all
  `HeroPanel` children. The `HeroJobBoard` component is the one that knows the circle of heroes who should be invited to listen to job requests, and it embeds 
  a `HeroPanel` component instance for each hero.
  
  In this scenario, `HeroPanel` declares an input property, `hero`, as the `@Input()` decorator suggests:
  
+makeExample('component-communication/ts/app/invite-heroes/hero-panel.ts', null, 'invite-heroes/hero-panel.ts', {pnk: /(@Input\(\))/g})

:marked
  `HeroJobBoard` iterates through its `invitedHeroes` collection and sets up its `HeroPanel` children so that a single hero is
  assigned to each of them through the `hero` input property. We use Angular property binding syntax 
  (property name wrapped into square brackets) to pass the current iteration hero to the child component:

+makeExample('component-communication/ts/app/invite-heroes/job-board-template.html', null, 'invite-heroes/job-board-template.html', {pnk: /(\[hero\])/g})

:marked
  When the application starts, `invitedHeroes` is empty, but clicking the __Invite heroes__ button invokes `inviteHeroes()` and 
  fills up the `invitedHeroes` array from the `Hero.heroes` static collection:
+makeExample('component-communication/ts/app/invite-heroes/hero-job-board.ts', null, 'invite-heroes/hero-job-board.ts', {pnk: /(inviteHeroes\(\))/g})
  
:marked
  According the template definition, the framework establishes these bindings between `HeroJobBoard` and its `HeroPanel` children:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/parent-and-children.png" alt="Input data binding")
  
:marked
.alert.is-helpful
  :marked
    We can access this sample through the `Invite` link of the [Live Example](/resources/live-examples/component-communication/ts/plnkr.html).
:marked
  When we run the app and click the **Invite heroes** button, the application UI reflects this stucture:

figure.image-display
  img(src="/resources/images/devguide/component-communication/heroes-invited-ui.png" alt="Heroes are invited")
  
:marked
  ### Can we change or alter an input property in the child component?
  
  As we mentioned earlier, when the `hero` property (the source expression) changes in `HeroJobBoard` (parent), the `Hero`
  input property of `HeroPanel` (destination) changes accordingly. In contrast, if we'd change `hero` in `HeroPanel` to another 
  hero's reference, that change would not flow back to `HeroJobBoard`. However, if we'd alter one or more properties of the `Hero`
  instance received from the parent &mdash; since `Hero` is an object &mdash;, that modification would flow back to the parent.
  
  ### Using `@Input`
  
  `Input` is defined in the core module of Angular, and we need to import it so that we can use it:
  
+makeExample('component-communication/ts/app/invite-heroes/hero-panel.ts', 'import', null, {blk: /(Input)/g})

:marked
  `@Input()` always must be used with parentheses:

+makeExample('component-communication/ts/app/invite-heroes/hero-panel.ts', 'input-def', null, {pnk: /(@Input\(\))/g})

:marked
.alert.is-critical
  :marked
    It's easy to forget the parentheses. Our application fails mysteriously if we do.
:marked
  Instead of using the `@Input()` annotation, we can use the `inputs` property of the `@Component` configuration object to specify input properties.

  Using the alternative method, we could have defined the `hero` input property this way:
  
code-example(format="linenums" language="javascript").
  @Component({
    inputs: ['hero']
  })
  export class HeroPanel {
    hero: Hero;
  }

:marked
.alert.is-helpful
  :marked
    In this chapter, we will always use the `@Input()` annotation.
:marked
  ### The convenience of input data binding
  
  The change detection mechanism of Angular makes input data binding easy-to-use. We can utilize the input property values in expressions, too,
  and it makes displaying data simple.
  
  We have already implemented the functionality behind the __Invite heroes__ function with input data binding. The same mechanism allows us
  to implement announcing jobs. As the altered definition of `HeroPanel` shows, now it has another input property, `request`, which has two
  occurrences within the template:

+makeExample('component-communication/ts/app/send-job-request/hero-panel.ts', 'component', 'send-job-request/hero-panel.ts (extract)', {pnk: /(&quot;request&quot;|{{request \|\|.*\}\})/g})

:marked
  As the value of `request` changes, the value of the `class` attribute changes, too, as well as the text of the `<h4>` tag through the 
  `request || 'No job announced'` expression. We simply add the `request` assignment to the `HeroJobBoard` template:
  
+makeExample('component-communication/ts/app/send-job-request/job-board-template.html', 'input-binding', 'send-job-request/job-board-template.html (extract)', {pnk: /(\[request\])/g})
:marked
  After inviting heroes, clicking the **Ask** button invokes `announceJob()`:
+makeExample('component-communication/ts/app/send-job-request/job-board-template.html', 'send', 'send-job-request/job-board-template.html (extract)')

:marked
  The `announceJob()` method is as simple as we expect:
  
+makeExample('component-communication/ts/app/send-job-request/hero-job-board.ts', null, 'send-job-request/hero-job-board.ts', {pnk: /(announceJob\(\))/g})

:marked
.alert.is-helpful
  :marked
    We can access this sample through the `Send Job Request` link of the [Live Example](/resources/live-examples/component-communication/ts/plnkr.html).

:marked
  When we run the sample, we can check how the new job request is propagated to all `HeroPanel` instances:

figure.image-display
  img(src="/resources/images/devguide/component-communication/send-job-request-ui.png" alt="Job request is sent")
  
:marked
  ### Catch input property changes
  
  Angular allows us to intercept property value changes in these ways:
  * We can create a setter method for an input property. In the setter we can check property values &mdash; handle
  invalid values &mdash; and carry out any additional tasks according to the component's logic.
  * We can use the `OnChanges` lifecycle hook and define the `ngOnChanges` lifecycle hook method that is called every time when the 
  framework detects a change in an input or output property's value. With this method, we can catch the names of affected propeties, 
  their previous and current values. 
.alert.is-helpful
  :marked
    We can learn more details about `ngOnChanges` and its usage in the [Lifecycle Hooks](./lifecycle-hooks.html) chapter.

:marked
  Let's alter the `HeroPanel` component so that it applies a property setter for `request` and intercepts the changes of all properties 
  (`hero` and `request`) to log them:
  
+makeExample('component-communication/ts/app/log-job-request/hero-panel.ts', 'class', 'log-job-request/hero-panel.ts', {pnk: /(set request|ngOnChanges)/g})

:marked
  The setter logs the job request, and adds a `***` prefix to an urgent request &mdash; to one that contains a '`$`' substring.
  The `ngOnChanges` method iterates through the changes, and logs each property's name, previous and current value.
  
.alert.is-helpful
  :marked
    We can access this sample through the `Log Job Request` link of the [Live Example](/resources/live-examples/component-communication/ts/plnkr.html).

:marked
  When we run the sample, we can check that the app transforms the **'I need urgent$ help'** job request to **'\*\*\* I need urgent help!'**:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/request-setter.png" alt="Request setter")
  
:marked
  We can also check that the setter of `request` and `ngOnChange` log property changes to the console output. This figure shows the bottom 
  of the log when we click the **Invite heroes** button:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/heroes-invited-log.png" alt="Heroes invited log")
  
:marked
  When we send a second job request after a first one, we can see a similar log excerpt:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/request-sent-log.png" alt="Request sent log")
  
:marked
  In this sample, heroes did not have a way to accept a job. Thinking in property binding, we could have passed an object to the child 
  component, which has a callback method that the child could use to sign that it undertakes the job (we could even pass the 
  parent `HeroJobBoard` instance to `HeroPanel`). However, that would be hacky.
  
  Child components don't use property binding to communicate with their parents. They can talk to their parents with _events_.
  
  ## #2: Child to parent communication with event emitting
  
  Input property binding is an easy-to-use technique that works great in most parent-to-child communication scenarios. As the expression bound to
  the input property changes, the modification immediately propagates to all children. At first we may think that this mechanism could be
  applied in the opposite direction, to send data from a child to its parent.
  
  _Angular does not implement input data binding in this direction._ It is a deliberate design decision. Angular was designed with 
  _unidirectional data flow_ in mind.
  
  As we already said, a child can communicate with its parent via events.
  
  ### Establish output event binding
  
  To set up output event emitting, we need to carry out these steps:
  1. Create a child property that returns an `EventEmitter`
  1. Declare it to be a public _output_ property
  1. Bind that property to a parent component event handler
  
  The Hero Job Board application uses output event binding to sign that a hero undertakes the announced job. The `HeroPanel` component declares 
  an output property as a type of `EventEmitter`, through which &mdash; as the type name suggests &mdash; it can emit an event. The parent 
  `HeroJobBoard` component can use the output property to attach an event handler to that particular event.
  
  `HeroPanel` declares the `onJobTaken` output event property, as the `@Output` decorator indicates:
  
+makeExample('component-communication/ts/app/take-job-event/hero-panel.ts', 'component', 'take-job-event/hero-panel.ts (extract)', {pnk: /(@Output\(\)|takeJob\(\)|onJobTaken\.emit|EventEmitter)/g})

:marked
  The `takeJob()` method invokes the `emit()` method of `onJobTaken`, and passes the `hero` assigned to this `HeroPanel`. 
  The parameter of `emit()` is the argument of the event emitted.
  
  To use `@Output()` and `EventEmitter`, `HeroPanel` needs to import them:
  
+makeExample('component-communication/ts/app/take-job-event/hero-panel.ts', 'import', null, {blk: /(Output|EventEmitter)/g})

:marked
  Now our `HeroPanel` is ready to emit its event. `HeroJobBoard` attaches its `heroTakesJob()` event handler method to the `onJobTaken` output
  event of `HeroPanel` using the output property binding syntax &mdash; wrapping the name of the output property, `onJobTaken`, into parentheses.
  The output property binding expression passes the `$event` identifier &mdash; that represents the argument of the emitted event &mdash; to the handler method:
  
+makeExample('component-communication/ts/app/take-job-event/job-board-template.html', 'event-binding', 'take-job-event/job-board-template.html (extract)', {pnk: /(onJobTaken)/g} )
  
:marked
  The event argument is the `hero` property value of `HeroPanel` that is passed to the `emit()` method of the `EventEmitter` instance beyond
  `onJobTaken`. `HeroJobBoard` receives the `Hero` instance that undertakes the job, and adds it to its `respondingHeroes` array.
  
+makeExample('component-communication/ts/app/take-job-event/hero-job-board.ts', 'announce', 'take-job-event/hero-job-board.ts', {pnk: /(\(onJobTaken\))/g, blk: /(heroTakesJob\(hero: Hero\))/g})

:marked
  With output event binding, we established this communication structure from `HeroPanel` children to `HeroJobBoard`:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/child-to-parent.png" alt="Output event binding")
  
.alert.is-helpful
  :marked
    We can access this sample through the `Take Job` link of the [Live Example](/resources/live-examples/component-communication/ts/plnkr.html).

:marked
  Now, we can invite heroes, announce job requests, and our heroes can opt to undertake the job. The `HeroJobBoard` component lists responding
  heroes in the UI:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/take-job-ui.png" alt="Hero undertakes job")
  
:marked
  ### Using `@Output`
  
.alert.is-critical
  :marked
    **`@Output()` always must be used with parentheses.** If we forget about it, our application fails inscrutably.
  
:marked
  Instead of decorating properties with the `@Output()` annotation, `@Component()` can be used to define output properties.
  We could have declared that `onJobTaken` is an output property by setting up the `outputs` property of `@Component`:
  
code-example(format="linenums" language="javascript").
  @Component({
    inputs: ['hero', 'request'],
    outputs: ['onJobTaken']
  })
  export class HeroPanel {
    hero: Hero;
    request: string;
    onJobTaken = new EventEmitter<Hero>();
  }

:marked
  ### Event arguments
  
  A child component can easily identify its parent during parent-to-child communication, as it has exactly one parent. Thus when a parent 
  sets an input property, the child exactly knows the source. However, when a parent component attaches an event handler method to an
  output event of its child components, it needs to take into account that messages may be received from multiple children. It does not means
  that the parent needs to know which of its children sends the message: nonetheless, the parent needs to know how to process the message, and
  it may depend on its source, the child that sends it.
  
  When we pass arguments to events, these arguments should contain all information the parent needs to know to process the child components'
  messages properly. We can use the non-generic `EventEmitter` type that allows using any type of event arguments. However, we'd better use
  events with well-defined arguments that can be represented with strong TypeScript types.
  
.alert.is-helpful
  :marked
    Angular encourages us to use strong event argument types whenever it's possible, because it allows creating more maintainable and
    less error-prone code.
  
:marked
  ## #3: Duplex parent/child communication through a service object
  
  When we use a hierarchy of application components, we do it for the sake of sharing the responsibilities among them. Each component manages its own state and
  represents it in the UI, and they communicate with each other to implement the functionality of the app. While it is a great thing that each 
  component can manage the state of their own UI, managing the UI logic often flows through multiple component types including parent and child components,
  often may involve more than two levels of the component hierarchy.
  
  Due to its distributed nature, it may be difficult to follow and maintain the flow of UI logic. Outsourcing this logic into a separate service may help
  the visibility and maintainability of this flow. Instead of parent and child components communicating with each other in both directions, each of 
  them communicates only with an intermediary service.
  
  ### Create `JobService`
  
  In this section, we refactor our `HeroJobBoard` and `HeroPanel` components, and move the UI workflow logic into a new service, `JobService`.
  Instead of communicating directly with each other, `HeroJobBoard` and `HeroPanel` communicates with `JobService`:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/job-service-communication.png" alt="JobService communication")
  
:marked
  `JobService` is composed from read-only properties, methods and events to protect the autonomy of the service. We move all state information that
  supports the UI workflow from `HeroJobBoard` and `HeroPanel` into `JobService`:
  
+makeExample('component-communication/ts/app/assign-job/job-service.ts', null, 'assign-job/job-service.ts')

:marked
  We added the `@Injectable()` annotation is to the service, because TypeScript only generates metadata for classes that have a decorator.
  We use dependency injection to let `HeroJobBoard` and `HeroPanel` to access `JobService`, and dependency injection needs metadata.
  
  The service provides only read-only properties (through getters accessing private members) so that we can avoid accidentally changing property values.
  When a component needs to change the state of the workflow, it can make it only through invoking `JobService` methods. Components need to be
  notified when something changed so that they can update the state of the UI snippet they are responsible for. `JobService` emits events
  for this purpose.
  
.alert.is-helpful
  :marked
    Using read-only properties is a question of architectural and programming style. We prefer using it, as it makes the service object
    more robust. Whether this style is used or not, it does not change the way we can establish inter-component communication
    through an intermediary service.
  
:marked
  ### Use `JobService`
  
  To make `JobService` available for `HeroJobBoard` and `HeroPanel`, we inject it into those components through their constructors.
  For a moment, let's forget about how this works, and let's focus about how the components use `JobService`. `HeroJobBoard` utilizes
  `JobService` this way:

+makeExample('component-communication/ts/app/assign-job/hero-job-board.ts', 'component', 'assign-job/hero-job-board.ts (extract)', {blk: /(private jobService: JobService)/g})

:marked
  We can observe that now `HeroJobBoard` does not store any relevant information about the workflow state, it obtains this data from
  `JobService` &mdash; through accessing its properties via `this.jobService`. The only state information it stores, `newRequest` contains
  only the local state of `HeroJobBoard`.
  
  `HeroPanel` uses `JobService` similarly:
  
+makeExample('component-communication/ts/app/assign-job/hero-panel.ts', 'component', 'assign-job/hero-panel.ts (extract)', {blk: /(private jobService: JobService)/g})

:marked
  We can observe that `request` is not an input property anymore, its value is set by the event handler of the `jobAssigned` event. Because we cannot 
  establish output event binding between `HeroPanel` and `JobService`, as `JobService` is not a parent component of `HeroPanel`, in the constructor 
  we need to subscribe to the `jobAnnounced` and `jobAssigned` events through the `jobAnnounced.subscribe()` and `jobAssigned.subscribe()` method 
  invocations, respectively. The `subscribe()` method receives the event handler function as its argument.
  
  ### Inject `JobService` into the components
  
  Now there is only one piece of information missing so that we can understand how this inter-component communication scenario works: we need to
  know how `JobService` is injected into `HeroJobBoard` and its `HeroPanel` children. Evidently, all components must use the very same 
  `JobService` instance; otherwise the UI workflow would not work.
  
  Angular dependency injection makes it very simple to deal with this scenario. We need to pass a single `JobService` instance to `HeroJobBoard`,
  and let the the framework do its work. Because all `HeroPanel` instances are the children of the single `HeroJobBoard`, the framework sets up
  injectors so that the very same `JobService` instance is injected into the constructor of all `HeroPanel` instances. Eventually, every
  component shares the same `JobService` instance:
  
+makeExample('component-communication/ts/app/assign-job/hero-job-board.ts', 'annotation', 'assign-job/hero-job-board.ts (extract)', {blk: /(providers: \[JobService\])/g})

.alert.is-helpful
  :marked
    We can access this sample through the `Assign Job` link of the [Live Example](/resources/live-examples/component-communication/ts/plnkr.html).

:marked
  Now, our app is fully functional, now we can not only invite heroes and let them take the job, but the person in can also assign it to a hero:
  
figure.image-display
  img(src="/resources/images/devguide/component-communication/app-ui-snapshot.png" alt="UI in action")
  
:marked
  ### When should we use intermediary components for communication?
  
  In the introductory part of this section we give a brief hint about why we opt to use `JobService` as an imtermediary communication component
  between `HeroJobBoard` and `HeroPanel`. Here, we list a few cases when a shared state service can be a viable choice to implement communication
  between (or among) components.
  
  1. We face with a complex, multi-stage, bidirectional workflow that is best represented by multiple touch points.
  1. As a corollary of such a workflow, we can avoid complex parent/child protocols that would otherwise flow over a single property channel.
  1. Children components should respond to messages and events from the parent.
  1. Child and parent components use compex state and logic (for example acquaring and managing data from a remote server).
  We can simplify our components by delegating this state and logic to a service.
  1. The communicating components are unrelated.
  
  We'd bettern not use shared services just for the sake of applying them. Whenever we can solve communication with input data binding and output
  event emitting, we should leverage these techniques.
  
  ## Conclusion
  
  Angular provides great communication mechanisms among components within an application. If we have components within the same tree or subtree,
  we have parent and child components, and can use these methods:
  * **Parent to child**: data binding with using one or more `@Input()` propery in the child component, the values of which can be assigned in the parent's 
  template.
  * **Child to parent**: event emitting with using one or more `@Output()` properties (`EventEmitter` instances) in the child component, the event handlers 
  of which can be assigned in the parent's template.
  
  If we have have unrelated components that are in separate subtrees, they can communicate **through intermediary components**, such as services:
  * The same intermediary component instance can be injected into the the communicating parties. 
  * The parties utilize the intermediary component, 
    * they can access its properties, 
    * invoke its methods,
    * and subscribe to its events.
    
  As we discussed, intermediary components are great alternatives for parent to child, and child to parent communication, too.
