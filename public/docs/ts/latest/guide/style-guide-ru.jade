include ../_util-fns

:marked
  Добро пожаловать в руководство по стилю кода Angular

  ## Цель руководства

  Ищете хорошее руководство по синтаксису, структуре приложений и всевозможным соглашениям принятым в Angular?
  Их есть у нас!
  Это "Руководство по стилю" показывает какие соглашения мы считаем предпочтительными и что немаловажно - объясняем почему.
.l-main-section

:marked
  ## Словарь Стиля

  Каждая часть руководства описывает хорошие или плохие практикии, все они имеют однотипный стиль представления.

  Формулировка каждой части руководства показывает насколько тот или иной совет рекомендуем на практике (или нет).

.s-rule.do
  :marked
    **Рекомендовано** это одна из тех практик, которых всегда нужно придерживаться.
    _Всегда,_ возможно, не самое подходящее слово, однако таких рекомендаций не так уж и много, как и ситуаций, в которых их можно нарушать.

.s-rule.consider
  :marked
    Рекомендациям **Попробуйте вот так**/**Постарайтесь**, как правило, нужно следовать.
    Если вы полностью понимаете смысл рекомендации и у вас есть веские основания отклониться от нее, тогда вперёд! Пожалуйста, будьте последовательными в отклонениях от рекомендаций.

.s-rule.avoid
  :marked
    **Остерегайтесь**/**Избегайте** это тип рекомендаций указывает на те моменты, которые вы почти всегда должны избегать. Примеры кода, которого стоит *избегать* помечены красной плашкой.
.l-main-section

:marked
  ## Файловая структура

  Некоторые примеры кода показывают файл, у которого есть один или несколько файлов-компаньонов с похожими именами. (например, hero.component.ts и hero.component.html).

  В этом руководстве мы будем использовать ярлыки `hero.component.ts | HTML | CSS | spec` для представления различных файлов. При помощи этих ярлыков мы упрощаем читаемость и сделаем лаконичнее представления файловых структур в руководстве.

.l-main-section
a(id='toc')

:marked
  ## Оглавление

    1. [Принцип Единственной Обязанности](#single-responsibility)
    1. [Наименование](#naming)
    1. [Coding Conventions](#coding-conventions)
    1. [App Structure and Angular Modules](#app-structure-and-angular-modules)
    1. [Компоненты](#components)
    1. [Директивы](#directives)
    1. [Сервисы](#services)
    1. [Data Services](#data-services)
    1. [Lifecycle Hooks](#lifecycle-hooks)
    1. [Приложение](#appendix)

.l-main-section
:marked
  ## Принцип Единственной Обязанности

  Применяйте [Принцип Единственной Обязанности](https://wikipedia.org/wiki/Single_responsibility_principle) ко всем компонентам, сервисами другим символам. 
  Это поможет сдеать код приложения чище, упростит его читаемость и поддержку, а кроме того, поможет проще его тестировать.

  ### <a id="01-01"></a>Rule of One
  #### <a href="#01-01">Style 01-01</a>
.s-rule.do
  :marked
    **Рекомендуется** определять один компонент в одном файле.

.s-rule.consider
  :marked
    **Постарайтесь** ограничить размер файлов до 400 строк кода.

.s-why
  :marked
    **Почему?** Рекомендация относительно разделения одного компонента на один файл улучшает читабельность и облегчает поддержку, а кроме того, помогает избежать непоняток между командами в системах управления версиями исходного кода.

.s-why
  :marked
    **Почему?** Один компонент в одном файле позволяет избежать скрытых ошибок, которые часто возникают при объединении нескольких компонентов в один файл, где они могут использовать одни и те же переменные, создавать нежелательные замыкания или связи с зависимостями.

.s-why.s-why-last
  :marked
    **Почему?** Один компонент может быть экспортом по умолчанию в его же файл, что упростит отложенную загрузку с роутингом.
:marked
  Суть в упрощении повторого использования кода, это весь код более читабельным и менее подверженным к ошибкам.

  В следующем *плохом* примере определяется `AppComponent`, загружается приложение, определяется объектная модель `Hero`, и загружаются герои с сервера ... и все это в одном файле. *Не делайте так :(*.

+makeExample('style-guide/ts/01-01/app/heroes/hero.component.avoid.ts', '', 'app/heroes/hero.component.ts')(avoid=1)
:marked
  Лучше разделить сам компонент и вспомогательную деятельность в отдельные файлы.

+makeTabs(
  `style-guide/ts/01-01/main.ts,
  style-guide/ts/01-01/app/app.module.ts,
  style-guide/ts/01-01/app/app.component.ts,
  style-guide/ts/01-01/app/heroes/heroes.component.ts,
  style-guide/ts/01-01/app/heroes/shared/hero.service.ts,
  style-guide/ts/01-01/app/heroes/shared/hero.model.ts,
  style-guide/ts/01-01/app/heroes/shared/mock-heroes.ts`,
  '',
  `main.ts,
  app/app.module.ts,
  app/app.component.ts,
  app/heroes/heroes.component.ts,
  app/heroes/shared/hero.service.ts,
  app/heroes/shared/hero.model.ts,
  app/heroes/shared/mock-heroes.ts`)

:marked
  С ростом приложения это правило становится только важнее.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="01-02"></a>Небольшие Функции
  #### <a href="#01-02">Style 01-02</a>
.s-rule.do
  :marked
    **Рекомендуется** определять маленькие функции

.s-rule.consider
  :marked
    **Постарайтесь** ограничить размер функции до 75 строк.

.s-why
  :marked
    **Почему?** Небольшие функции проще тестировать, особенно когда они выполняют одну функцию и служат для одной цели.

.s-why
  :marked
    **Почему?** Небольшие функции упрощают повторное использование кода.

.s-why
  :marked
    **Почему?** Небольшие фунции проще читать.

.s-why
  :marked
    **Почему?** Небольшие функции проще поддерживать.

.s-why.s-why-last
  :marked
    **Почему?** Небольшие функции помогают избежать скрытых ошибок, которые возникают у больших функций, которые разделяют переменные с внешней зоной видимости, создаются нежелательные замыкания или нежелательные связи с зависимостями.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Присвоение имён

  Соглашения о именовании очень важны для поддержки и чатабельности кода. Это руководство советует как правильно присваивать имена файлам и сиволам.

.l-main-section
:marked
  ### <a id="02-01"></a>Общие инструкции по присвоению имен
  #### <a href="#02-01">Style 02-01</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать однотипные имена для всех элементов.

.s-rule.do
  :marked
    **Рекомендуется** следовать определенной схеме, которая описывает сначала возможности элемента, а потом его тип. Рекомендуемая схема наименования: `feature.type.ts`.

.s-why
  :marked
    **Почему?** Соглашения об именовании помогают ускорить поиск информации. Согласованность в рамках проекта очень важно. Согласованность с командой также имеет важное значение. Согласованность во всей компании плвышает общую эффективность.

.s-why
  :marked
    **Почему?** Эти правила именования просто должны  помочь найти нужный код быстрее и сделать его более понятным.

.s-why.s-why-last
  :marked
    **Почему?** Имена папок и файлов должны четко показывать, что в них содержится и для чего они нужны. Например, `app/heroes/hero-list.component.ts` может содержать компонент, который управляет списком героев.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-02"></a>Разделяйте имена файлов точками и дефисами
  #### <a href="#02-02">Style 02-02</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать дефисы для разделения слов в описательном имени.

.s-rule.do
  :marked
    **Рекомендуется** использовать точки для разделения описательного имени от типа файла.

.s-rule.do
  :marked
    **Рекомендуется** использовать однотипные имена файлов для всех компонентов по одному шаблону, который описаывает сначала возможности компонента, а потом его тип. Рекомендованый шаблон `feature.type.ts`.

.s-rule.do
  :marked
    **Рекомендуется** использовать привычные имена типов, включая `.service`, `.component`, `.pipe`, `.module`, `.directive`. 
    Придумывайте дополнительные имена типов, если необходимо, но будьте осторожны, не создавайте слишком много.

.s-why
  :marked
    **Почему?** Имена типов предоставляют единый метод быстрого определения того, что находится в файле.

.s-why
  :marked
    **Почему?** Это упростит нахождение определенного типа файлов с помощью текстового редактора или встроенного в IDE поиска.

.s-why
  :marked
    **Почему** Несокращённые имена типов, такие как `.service` описательны и недвусмысленны.
    Сокращения, такие как `.srv`,` .svc`, и `.services` могут сбивать с толку.

.s-why.s-why-last
  :marked
    **Почему?** Это обеспечит соответствие шаблону для любых автоматизированных задач..

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-03"></a>Элементы и Имена Файлов
  #### <a href="#02-03">Style 02-03</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать однотипные имена для всех ресурсов, в зависимости от того, что в них содержится.

.s-rule.do
  :marked
    **Рекомендуется** использовать верхний регистр для имен классов. Согласуйте имя элемента с именем файла.

.s-rule.do
  :marked
    **Рекомендуется** добавлять имя элемента с традиционным суффиксом к элементам соответствующего типа.
    (например, `Component`, `Directive`, `Module`, `Pipe`, `Service`).

.s-rule.do
  :marked
    **Рекомендуется** давать имени файла традиционный суффикс для файлов данного типа.
    (например, `.component.ts`, `.directive.ts`, `.module.ts`, `.pipe.ts`, `.service.ts`).
.s-why
  :marked
    **Почему?** Это предоставляет логичный способ для быстрого определения и учета ресурсов.

.s-why.s-why-last
  :marked
    **Почему?** Верхний регистр является традиционным для идентификации объектов, которые могут быть инстанцированы с помощью конструктора.

- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th Symbol Name
    th File Name
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class AppComponent { }
    td
      :marked
        app.component.ts
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class HeroesComponent { }
    td
      :marked
        heroes.component.ts
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class HeroListComponent { }
    td
      :marked
        hero-list.component.ts
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class HeroDetailComponent { }
    td
      :marked
        hero-detail.component.ts
  tr(style=top)
    td
      code-example.
        @Directive({ ... })
        export class ValidationDirective { }
    td
      :marked
        validation.directive.ts
  tr(style=top)
    td
      code-example.
        @NgModule({ ... })
        export class AppModule
    td
      :marked
        app.module.ts
  tr(style=top)
    td
      code-example.
        @Pipe({ name: 'initCaps' })
        export class InitCapsPipe implements PipeTransform { }
    td
      :marked
        init-caps.pipe.ts
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class UserProfileService { }
    td
      :marked
        user-profile.service.ts
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-04"></a>Наименование Сервисов
  #### <a href="#02-04">Style 02-04</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать однотипные имена для всех сервисов в соответствии с их функционалом.

.s-rule.do
  :marked
    **Рекомендуется** использовать верхний регистр при именовании сервисов.

.s-rule.do
  :marked
    **Рекомендуется** добавлять суффиксы `Service` к сервисам, когда не ясно, какую функцию они выполняют (например, когда в названии используются существительные).

.s-why
  :marked
    **Почему?** Это предоставляет логичный способ для быстрого определения и учета сервисов.

.s-why
  :marked
    **Почему?** Очевидные имена сервисов, такие как `Logger` не требуют дополнительных суффиксов.

.s-why.s-why-last
  :marked
    **Почему?** Имена сервисов, такие как `Credit` - существительные и требуют добавления суффикса. Это необходимо, если не очевидно, сервис это или что-то другое.

- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th Symbol Name
    th File Name
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class HeroDataService { }
    td
      :marked
        hero-data.service.ts
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class CreditService { }
    td
      :marked
        credit.service.ts
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class Logger { }
    td
      :marked
        logger.service.ts
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-05"></a>Бутстрэппинг
  #### <a href="#02-05">Style 02-05</a>

.s-rule.do
  :marked
    **Рекомендуется** поместить всю логику приложения и начальную инициализации в файл `main.ts`.

.s-rule.do
  :marked
    **Рекомендуется** включать обработчик ошибок в логику инициализации.

.s-rule.avoid
  :marked
    **НЕ** помещайте логику самого приложения в `main.ts`. Вместо этого, поместите её в компонент или сервис.

.s-why
  :marked
    **Почему?** Это помогает организовывать однотипную логику запуска приложения.

.s-why.s-why-last
  :marked
    **Почему?** Это помогает следовать знакомым правилам, которые используются в других технологиях.

+makeExample('style-guide/ts/02-05/main.ts', '', 'main.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-06"></a>Селекторы директив
  #### <a href="#02-06">Style 02-06</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать нижний ВерблюжийРегистр для именования селекторов директив.

.s-why
  :marked
    **Почему?** Это помогает сохранить имена свойств, определенных в директивах, которые привязаны к представлению в соответствии с именами атрибутов.

.s-why.s-why-last
  :marked
    **Почему?** HTML парсер в Angular чувствителен к регистру, поэтому он будет распознавать нижний регистр.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-07"></a>Пользовательский префикс для компонентов
  #### <a href="#02-07">Style 02-07</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать дефис и значения элемента селектора в нижнем регистре (например `admin-users`). 
    

.s-rule.do
  :marked
    **Рекомендуется** использовать пользовательский префикс для компонента селектора. 
    Например, префикс `toh` означает  **T**our **o**f **H**eroes а префикс `admin` соответственно означает администратора области функционала.

.s-rule.do
  :marked
    **Рекомендуется** использовать префикс, который указывает на область функции или само приложение.

.s-why
  :marked
    **Почему?** Это помогает избежать конфликта имён элементов с компонентами в других приложениях и с нативными HTML элементами.

.s-why
  :marked
    **Почему?** Это упрощает использование компонента в других приложениях.

.s-why.s-why-last
  :marked
    **Почему?** Компоненты становится легко отличить в DOM.

+makeExample('style-guide/ts/02-07/app/heroes/hero.component.avoid.ts', 'example', 'app/heroes/hero.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/02-07/app/users/users.component.avoid.ts', 'example', 'app/users/users.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/02-07/app/heroes/hero.component.ts', 'example', 'app/heroes/hero.component.ts')
:marked

+makeExample('style-guide/ts/02-07/app/users/users.component.ts', 'example', 'app/users/users.component.ts')
:marked

:marked
  ### <a id="02-08"></a>Пользовательский префикс для директив
  #### <a href="#02-08">Style 02-08</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать специальный префикс для селекторов директив (например, префикс `toh` - **T**our **o**f **H**eroes).

.s-rule.do
  :marked
    **Рекомендуется** называть селекторы не по элементам в нижнем регистре, кроме случаев, когда селектор должен совпадать с нативным HTML аттрибутом.

.s-why
  :marked
    **Почему?** Это помогает избежать конфликтов в именах директив.

.s-why.s-why-last
  :marked
    **Почему?** Таким образом директивы проще отличить визуально.

+makeExample('style-guide/ts/02-08/app/shared/validate.directive.avoid.ts', 'example', 'app/shared/validate.directive.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/02-08/app/shared/validate.directive.ts', 'example', 'app/shared/validate.directive.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-09"></a>Наименование Пайпов
  #### <a href="#02-09">Style 02-09</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать однотипные имена для всех пайпов в соответствии с их функционалом.

.s-why.s-why-last
  :marked
    **Почему?** Это предоставляет логичный способ для быстрого определения и учета пайпов.

- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th Symbol Name
    th File Name
  tr(style=top)
    td
      code-example.
        @Pipe({ name: 'ellipsis' })
        export class EllipsisPipe implements PipeTransform { }
    td
      :marked
        ellipsis.pipe.ts
  tr(style=top)
    td
      code-example.
        @Pipe({ name: 'initCaps' })
        export class InitCapsPipe implements PipeTransform { }
    td
      :marked
        init-caps.pipe.ts
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-10"></a>Назименование файлов с Юнит-тестами
  #### <a href="#02-10">Style 02-10</a>

.s-rule.do
  :marked
    **Рекомендуется** называть файлы с тестами так же, как компонент который они тестируют.

.s-rule.do
  :marked
    **Рекомендуется** называть файлы с тестовой спецификацией, добавляя суффикс `.spec`.

.s-why
  :marked
      **Почему?** Таким образом тесты проще отличить визуально.

.s-why.s-why-last
  :marked
      **Почему?** Это упрощает создание шаблонов для [karma](http://karma-runner.github.io/) и других тест-раннеров.

:marked
- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th Symbol Name
    th File Name
  tr(style=top)
    td
      :marked
        Components
    td
      :marked
        heroes.component.spec.ts
      :marked
        hero-list.component.spec.ts
      :marked
        hero-detail.component.spec.ts
  tr(style=top)
    td
      :marked
        Services
    td
      :marked
        logger.service.spec.ts
      :marked
        hero.service.spec.ts
      :marked
        filter-text.service.spec.ts
  tr(style=top)
    td
      :marked
        Pipes
    td
      :marked
        ellipsis.pipe.spec.ts
      :marked
        init-caps.pipe.spec.ts
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-11"></a>Наименование файлов с end-to-end тестами
  #### <a href="#02-11">Style 02-11</a>

.s-rule.do
  :marked
   **Рекомендуется** называть файлы со спецификацией end-to-end тестов, добавляя суффикс `.e2e-spec`.

.s-why
  :marked
    **Почему?** Таким образом end-to-end тесты проще отличить визуально.

.s-why.s-why-last
  :marked
    **Почему?** Это упрощает использование шаблонов для автоматизации сборок и работы тест-раннеров.

:marked
:marked
- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th Symbol Name
    th File Name
  tr(style=top)
    td
      :marked
        End to End Tests
    td
      :marked
        app.e2e-spec.ts
      :marked
        heroes.e2e-spec.ts
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="02-12"></a>Наименование модулей в Angular
  #### <a href="#02-12">Style 02-12</a>

.s-rule.do
  :marked
    **Рекомендуется** добавлять к имени элемента суффикс `Module`.

.s-rule.do
  :marked
    **Рекомендуется** добавлять к имени файла расширение `.module.ts`

.s-rule.do
  :marked
    **Рекомендуется** называть модуль в соответствии с его функционалом и папки, в которой он находится.

.s-why
  :marked
    **Почему?** Это предоставляет логичный способ для быстрого определения и учета модулей.

.s-why
  :marked
    **Почему?** Верхний регистр привычен и удобен для определения объектов, которые могут быть созданы с помощью конструктора.

.s-why.s-why-last
  :marked
    **Почему?** Таким образом удобнее определять модуль как корень одноименной функции.

.s-rule.do
  :marked
    **Рекомендуется** добавлять `RoutingModule` суффикс к классу _RoutingModule_.

.s-rule.do
  :marked
    **Рекомендуется** добавлять к концу имени файла _RoutingModule_ суффикс `-routing.module.ts`.

.s-why.s-why-last
  :marked
    **Почему?** Модуль `RoutingModule` представляет собой модуль, необходимый исключительно для настройки Angular роутера. 
    Одинаковые имена класса и файла упрощают их обнаружение и верификацию.
- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th Symbol Name
    th File Name
  tr(style=top)
    td
      code-example.
        @NgModule({ ... })
        export class AppModule { }
    td
      :marked
        app.module.ts
  tr(style=top)
    td
      code-example.
        @NgModule({ ... })
        export class HeroesModule { }
    td
      :marked
        heroes.module.ts
  tr(style=top)
    td
      code-example.
        @NgModule({ ... })
        export class VillainsModule { }
    td
      :marked
        villains.module.ts
  tr(style=top)
    td
      code-example.
        @NgModule({ ... })
        export class AppRoutingModule { }
    td
      :marked
        app-routing.module.ts
  tr(style=top)
    td
      code-example.
        @NgModule({ ... })
        export class HeroesRoutingModule { }
    td
      :marked
        heroes-routing.module.ts        
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Соглашение по оформлению кода

  Это соглашение - набор consistent set of coding, naming, and whitespace conventions.

.l-main-section
:marked
  ### <a id="03-01"></a>Классы
  #### <a href="#03-01">Style 03-01</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать верхний регистр при именовании классов.

.s-why
  :marked
    **Почему?** Это традиционный способ именования классов.

.s-why.s-why-last
  :marked
    **Почему?** Класс можно инстанцирован или, другими словами, можно создать экземпляр класса.
    Согласно договоренностям, верхний регистр используется для индикации конструируемых объектов.

+makeExample('style-guide/ts/03-01/app/core/exception.service.avoid.ts', 'example', 'app/shared/exception.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-01/app/core/exception.service.ts', 'example', 'app/shared/exception.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="03-02"></a>Константы
  #### <a href="#03-02">Style 03-02</a>

.s-rule.do
  :marked
    **Рекомендуется** определять переменные, добавляя к ним приставку `const`, если их значение не должно меняться никогда.

.s-why
  :marked
    **Почему?** Таким образом проще показать тому, кто читает код, что эта переменная остается незименной.

.s-why.s-why-last
  :marked
    **Почему?** TTypeScript помогает соблюдать эту договоренность, требуя немедленной инициализации 
    и тем самым предотвращает случайное переопределение в будущем.
    
.s-rule.consider
  :marked
    **Постарайтесь** называть `const`-переменные в нижнем регистре.

.s-why
  :marked
    **Почему?** имена переменных в нижнем регистре (например, `heroRoutes`) удобнее читать и проще понять,
    чем имена в класическом ВЕРХНЕМ_РЕГИСТРЕ_C_ПОДЧЕРКИВАНИЕМ (`HERO_ROUTES`).

.s-why.s-why-last
  :marked
    **Почему?** Традиция присвоения имен констант в ВЕРХНЕМ_РЕГИСТРЕ_C_ПОДЧЕРКИВАНИЕМ 
    появилась в эпоху до современных удобных IDE. Сам TypeScript предотвращает
    случайное переопределение переменных. 
    
.s-rule.do
  :marked
    **Рекомендуется** оставить _существуюшие_ переменные `const` ТАКОГО_ВИДА как есть.

.s-why.s-why-last
  :marked
    **Почему?** Традиция называть перемиенные в ВЕРХНЕМ_РЕГИСТРЕ остается популярной и 
    распространенной, особенно в сторонних модулях.
    Редко когда действительно стоит приложить усилия и изменить имена переменных, т.к высок риск сломать существующий код и документацию.

+makeExample('style-guide/ts/03-02/app/core/data.service.ts', '', 'app/shared/data.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="03-03"></a>Интерфейсы
  #### <a href="#03-03">Style 03-03</a>

.s-rule.do
  :marked
    **Рекомендуется** называть интерфейсы в верхнем регистре.

.s-rule.consider
  :marked
    **Постарайтесь** не называть сервисы используя префикс `I`.

.s-rule.consider
  :marked
    **Постарайтесь** использовать классы вместо интерфейсов. 

.s-why
  :marked
    **Почему?** <a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines" target="_blank">Руководство по стилю TypeScript</a> 
    настоятельно НЕ советует пользоваться префиксом "I".

.s-why
  :marked
    **Почему?** В одном классе меньше кода, чем в _классе-плюс-интерфейс_.

.s-why
  :marked
    **Почему?** Сам класс может работать как интерфейс (use `implements` instead of `extends`).

.s-why.s-why-last
  :marked
    **Почему?** An interface-class can be a provider lookup token in Angular dependency injection.

+makeExample('style-guide/ts/03-03/app/core/hero-collector.service.avoid.ts', 'example', 'app/shared/hero-collector.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-03/app/core/hero-collector.service.ts', 'example', 'app/shared/hero-collector.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="03-04"></a>Свойства и Методы
  #### <a href="#03-04">Style 03-04</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать нижний ВерблюжийРегистр для именования свойств и методов.

.s-rule.avoid
  :marked
    **Избегайте** добавления префикса `_` к private свойствам и методам.

.s-why
  :marked
    **Почему?** Таким образом соблюдается привычное представление об именовании свойств и методов.

.s-why
  :marked
    **Почему?** В JavaScript нету настоящих private свойств или методов.

.s-why.s-why-last
  :marked
    **Почему?** Так утилитам для TypeScript проще определять private или public свойства и методы.

+makeExample('style-guide/ts/03-04/app/core/toast.service.avoid.ts', 'example', 'app/shared/toast.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-04/app/core/toast.service.ts', 'example', 'app/shared/toast.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="03-06"></a>Междустрочный интервал в импортах
  #### <a href="#03-06">Style 03-06</a>

.s-rule.consider
  :marked
    **Постарайтесь** оставлять пустую строку между импортами сторонних модулей и импортами самого приложения.

.s-rule.consider
  :marked
    **Постарайтесь** сортировать импорты по алфавитному порядку.

.s-rule.consider
  :marked
    **Постарайтесь** cортировать импорты ассетов по алфавиту.

.s-why
  :marked
    **Почему?** Пустая строка улучшает читаемость и позволяет найти нужные импорты.

.s-why.s-why-last
  :marked
    **Почему?** Сортировка по алфавиту улучшает читаемость и позволяет найти нужные импорты. 

+makeExample('style-guide/ts/03-06/app/heroes/shared/hero.service.avoid.ts', 'example', 'app/heroes/shared/hero.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-06/app/heroes/shared/hero.service.ts', 'example', 'app/heroes/shared/hero.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Структура приложения и модули Angular

  Всегда имейте в виду краткосрочную перспективу и долгосрочную перспективу реализации проекта. Начнайте с малого, но всегда помните о том, в какую сторону будет развиваться приложение в будущем.

  Весь код приложения должен быть в папке под названием `app`.
  Все функциональные области должны быть разедлены по соответствующим папкам с соответсвующим модулем Angular. 
  
  Все содержимое должно быть разделено по принципу 1 ассет в 1 файле. Каждый компонент, сервис и пайп должен находится в своем собственном файле.
  Все сторонние скрипты, хранятся в другой (не в `app`) папке. 
  Не я их писал, и я не хочу чтобы они находились внутри моего приложения 
  Пользуйтесь советами по именованию файлов из этого руководства.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-01"></a>Принцип LIFT
  #### <a href="#04-01">Style 04-01</a>

.s-rule.do
  :marked
    **Рекомендуется** структурировать свое приложение таким образом, чтобы легко можно было найти нужный участок кода (`L` - locate)
    определить назначение файла (`I` - identify),
    не усложняйте структуру (`F` - flat),
    старайтесь не повторять себя (`T`ry to stay DRY).

.s-rule.do
  :marked
    **Do** define the structure to follow these four basic guidelines, listed in order of importance.

.s-why.s-why-last 
  :marked
    **Почему?** LIFT обеспечивает постоянную, легко расширяемую структуру, является модульным и позволяет легко находить нужные компоненты
    Также есть простой способ определить насколько хороша ваша структура, подумайте над тем: 
    _сколько файлов вам надо открыть для работы над одним функционалом._?

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-02"></a>Место расположения
  #### <a href="#04-02">Style 04-02</a>

.s-rule.do
  :marked
    **Рекомендуется** стараться делать нахождение кода интиутивным, простым и быстрым.

.s-why.s-why-last
  :marked
    **Почему?**  
    Если вы не сможете быстро найти нужный участок кода, то вы не сможете эффективно работать над проблемой. 
    Вы можете не знать имя файла или где расположены связанные файлы, поэтому очень важно располагать все их поблизости. 
    Располагать относящиеся друг к другу файлы рядом друг с другом сокращает время на поиски нужной части приложения. 
    Описательная структура папок действительно упрощает жизнь вам и всем, кто будет работать с кодом после вас.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-03"></a>Определение назначения файла
  #### <a href="#04-03">Style 04-03</a>

.s-rule.do
  :marked
    **Рекомендуется** называть файл так, чтобы из названия файла сразу было понятно его назначение.

.s-rule.do
  :marked
    **Рекомендуется** описывать назначение файла в его названии и не держать больше одного компонента в одном файле.

.s-rule.avoid
  :marked
    **Избегайте** файлов с несколькими контроллерами, сервисами или смеси из того и другого. 

.s-why.s-why-last
  :marked
    **Почему?** Вы тратите гораздо меньше времени на разбирание кода и работаете намного быстрее. 
    Ничего страшного даже если для этого вам потребуются более длинные имена файлов.

.l-sub-section
  :marked
    Существуют правила, которые вытекают из правила _1 компонент на файл,_  
    огда, к примеру, у вас есть набор небольших связанных между собой функций, 
    но все же довольно легко понять их назначение.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-04"></a>Простая структура
  #### <a href="#04-04">Style 04-04</a>

.s-rule.do
  :marked
    **Рекомендуется** сохранять плоскую структуру каталогов как можно больше.

.s-rule.consider
  :marked
    **Постарайтесь** создавать подпапки только по достижению 7 и больше файлов в основной директории.

.s-rule.consider
  :marked
    **Постарайтесь** настроить среду разработки так, чтобы она скрывала отвлекающие и ненужные файлы, такие как:  автоматически сгенерированные `.js` и `.js.map` файлы.

s-why.s-why-last
  :marked
    **Почему?** Никому не хочется проходить 7 каталогов вглубь, чтобы добраться до одного файла.
    Плоская структура директорий проще воспринимается.
    
    С другой стороны,
    <a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" target="_blank">психологи говорят,</a>
    что человеку становится сложно воспринимать интересные вещи, когда они находятся поблизости друг к другу и их количество превышает девять.
    Поэтому когда в папке накапливается десять или более файлов, то, возможно, настало время для создания вложенных папок.
    
    Делайте так, как вам удобно.
    Не усложняйте структуру проекта без причины.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-05"></a>Не повторяйте свой код
  #### <a href="#04-05">Style 04-05</a>

.s-rule.do
  :marked
    **Рекомендуется** писать сжато, не дублируйте свой код

.s-rule.avoid
  :marked
    **Избегайте** упрощения в урерб читаемости.

.s-why.s-why-last
  :marked
    **Почему?** Такой подход немаловажен, но не стоит быть фанатичным и нарушать другие принципы LIFT.
    Не хотелось бы набирать `hero-view.component.html` для вида(view), так как и так понятно что это вид. 
    Если бы это не было ясно из принятых правил, то тогда есть смысл употреблять такое имя.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-06"></a>Общие правила структуры приложения
  #### <a href="#04-06">Style 04-06</a>

.s-rule.do
  :marked
    **Всегда** начинайте с малого, но помните куда ваше приложение движется.

.s-rule.do
  :marked
    **Всегда** держите в уме не только то, что надо реализовать сейчас, но и смотрите вперед.

.s-rule.do
  :marked
    **Рекомендуется всегда** хранить весь код приложения в каталоге `app`.

.s-rule.consider
  :marked
    **Постарайтесь** создавать отдельную папку для компонента у которого есть несколько сопутствующих файлов (`.ts`, `.html`, `.css` and `.spec`).

.s-why
  :marked
    **Почему?** Помогает сохранить структуру приложения плоской и простой в обслуживании на ранних стадиях, в то же время удобной для расширения с ростом приложения.

.s-why.s-why-last
  :marked
    **Почему?** У компонентов обычно есть 4 сопутствубщих файла (например `*.html`, `*.css`, `*.ts`, and `*.spec.ts`) и они могут быстро захламить собой папку.

a(id='file-tree')
:marked
  Вот пример правильной структуры папок и файлов

.filetree
  .file &lt;project root&gt;
  .children
    .file app
    .children
      .file core
      .children
        .file core.module.ts
        .file exception.service.ts|spec.ts
        .file user-profile.service.ts|spec.ts
      .file heroes
      .children
        .file hero
        .children
          .file hero.component.ts|html|css|spec.ts
        .file hero-list
        .children
          .file hero-list.component.ts|html|css|spec.ts
        .file shared
        .children
          .file hero-button.component.ts|html|css|spec.ts
          .file hero.model.ts
          .file hero.service.ts|spec.ts
        .file heroes.component.ts|html|css|spec.ts
        .file heroes.module.ts
        .file heroes-routing.module.ts
      .file shared
      .children
        .file shared.module.ts
        .file init-caps.pipe.ts|spec.ts
        .file text-filter.component.ts|spec.ts
        .file text-filter.service.ts|spec.ts
      .file villains
      .children
        .file villain
        .children
          .file ...
        .file villain-list
        .children
          .file ...
        .file shared
        .children
          .file ...
        .file villains.component.ts|html|css|spec.ts
        .file villains.module.ts
        .file villains-routing.module.ts
      .file app.component.ts|html|css|spec.ts
      .file app.module.ts
      .file app-routing.module.ts
    .file main.ts
    .file index.html
    .file ...
:marked

.l-sub-section
  :marked
    В то время как структура компонентов в выделенной папке находит широкое применение, 
    еще один вариант для небольших приложений - это держать структуру компонентов плоской. 
    Что бы вы не выбрали - будьте последовательны и следуйте одному выбранному пути.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-07"></a>Каталог на один функционал
  #### <a href="#04-07">Style 04-07</a>

.s-rule.do
  :marked
    **Рекомендуется** создавать каталоги и называть их в соответствии с функционалом.

.s-why
  :marked
    **Почему?** Разработчик легко найдет нужный код, определит его назначение при виде файла, проще структуры быть не может, а также отсутствуют какие-либо повторения.

.s-why
  :marked
    **Почему?** Принципы LIFT полностью соблюдены.

.s-why
  :marked
    **Почему?** Предотвращает засорение проекта и придерживает проект в рамках LIFT.

.s-why
  :marked
    **Почему?** Когда файлов больше 10 в одном каталоге, то их проще находить по подкаталогам, чем в одной директории.

.s-rule.do
  :marked
    **Рекомендуется** создавать небольшие модули отвечающие за одну функцию.

.s-why
  :marked
    **Почему?** Модули Angular позволяют упростить lazy-loading поддерживающих маршрутизацию функций.

.s-why.s-why-last
  :marked
    **Почему?** Angular модули упрощают изоляцию, тестирование и повторное использование возможностей.

.file-tree-reference
  a(href="#file-tree") Обращайтесь к этому примеру структуры файлов и каталогов при необходимости

a(href="#toc") Вернуться наверх
  :marked

.l-main-section
:marked
  ### <a id="04-08"></a>Корневой модуль приложения
  #### <a href="#04-08">Style 04-08</a>

.s-rule.do
  :marked
    **Рекомендуется** создать модуль Angular в корневом каталоге приложения (например, in `/app`).

.s-why
  :marked
    **Почему?** Каждое приложение Angular имеет как минимум один корневой модуль.

.s-rule.consider
  :marked
    **Постарайтесь** всегда называть корневой модуль одинаково - `app.module.ts`.

.s-why.s-why-last
  :marked
    **Почему?** Это упрощает нахождение и идентификацию корневого модуля.

+makeExample('style-guide/ts/04-08/app/app.module.ts', 'example', 'app/app.module.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-09"></a>Модули, отвечающие за определенную область функционала
  #### <a href="#04-09">Style 04-09</a>
.s-rule.do

  :marked
    **Рекомендуется** создавать модули, отвечающие за определенную область функционала.

.s-rule.do
  :marked
    **Рекомендуется** размещать модуль отвечающий за определенную область функционала в папку с соответствующим фунционалу названием (например, `app/heroes`).

.s-rule.do
  :marked
    **Рекомендуется** называть файл модуля отвечающего за определенную область функционала соответствующе названию папки и функционалу именем (например, `app/heroes/heroes.module.ts`)

.s-rule.do
  :marked
    **Рекомендуется** называть элемент модуля отвечающего за определенную область функционала соответствующе названию папки и функционалу именем (например, `app/heroes/heroes.module.ts` определяет `HeroesModule`)

.s-why
  :marked
    **Почему?** Модуль отвечающий за определенную область функционала может раскрывать или скрывать его реализацию от других модулей.

.s-why
  :marked
    **Почему?** Модуль отвечающий за определенную область функционала определяет различные наборы связанных компонентов, входящих в область функции.

.s-why
  :marked
    **Почему?** Модуль функции может быть подключен как lazy-загрузкой так и eager-загрузкой. 

.s-why
  :marked
    **Почему?** Модуль функции задает четкие границы между определенным функционалом и другими функциями приложения. 

.s-why
  :marked
    **Почему?** Модуль функции помогает прояснить и облегчить распределение обязанностей по различным командам.

.s-why.s-why-last
  :marked
    **Почему?** Разделение областей функционала по модулям облегчает изолированное тестирование и упрощает повторное использование модуля.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-10"></a>Shared Feature Модули
  #### <a href="#04-10">Style 04-10</a>

.s-rule.do
  :marked
    **Рекомендуется** создавать модуль функции называя его`SharedModule` в папке `shared`(например `app/shared/shared.module.ts` определяет `SharedModule`).

.s-rule.do
  :marked
    **Рекомендуется** хранить общие компоненты, директивы и пайпы, которые будут использоваться другими модулями в приложении в `SharedModule`, где ожидается, что эти элекменты будут порождать новый инстанс самих себя (не синглтоны).

.s-rule.do
  :marked
    **Рекомендуется** испортировать все модули необходимые элементам в `SharedModule` (например, `CommonModule` and `FormsModule`).

.s-why
  :marked
    **Почему?** `SharedModule` будет содержать компоненты, директивы и пайпы, которым могут понадобиться возможности из common модулей (e.g. `ngFor` in `CommonModule`).

.s-rule.do
  :marked
    **Рекомендуется** объявлять все компоненты, директивы и пайпы в `SharedModule`.

.s-rule.do
  :marked
    **Рекомендуется** экспортировать все элементы, которые могут понадобиться в других модулях функций из `SharedModule`.  

.s-why
  :marked
    **Почему?** `SharedModule` необходим, чтобы сделать доступными часто используемые компоненты, директивы и пайпы  для использования в шаблонах компонентов во многих других модулях.

.s-rule.avoid
  :marked
    **Избегайте** указания синглтон провайдеров используемых в масштабах всего приложения в `SharedModule`. Намеренное использование синглтонов допускается. Берегите себя!

.s-why
  :marked
    **Почему?** Модуль функции загруженный через lazy-loading, который импортирует shared модуль создаст свою копию сервиса и скорее всего приведет к нежелательным результатам.

.s-why.s-why-last
  :marked
    **Почему?** Нежелательно, чтобы у каждого модуля был свой отдельный инстанс сервисов синглтона. 
    Существует реальная опасность такого, если `SharedModule` предоставляет сервис.

.filetree
  .file src
  .children
    .file app
    .children
      .file shared
      .children
        .file shared.module.ts
        .file init-caps.pipe.ts|spec.ts
        .file text-filter.component.ts|spec.ts
        .file text-filter.service.ts|spec.ts
      .file app.component.ts|html|css|spec.ts
    .file app.module.ts
    .file app-routing.module.ts
    .file main.ts
    .file index.html
    .file ...
:marked

+makeTabs(
  `style-guide/ts/04-10/app/shared/shared.module.ts,
  style-guide/ts/04-10/app/shared/init-caps.pipe.ts,
  style-guide/ts/04-10/app/shared/filter-text/filter-text.component.ts,
  style-guide/ts/04-10/app/shared/filter-text/filter-text.service.ts,
  style-guide/ts/04-10/app/heroes/heroes.component.ts,
  style-guide/ts/04-10/app/heroes/heroes.component.html
  `,
  `,,,`,
  `app/shared/shared.module.ts,
  app/shared/init-caps.pipe.ts,
  app/shared/filter-text/filter-text.component.ts,
  app/shared/filter-text/filter-text.service.ts,
  app/heroes/heroes.component.ts,
  app/heroes/heroes.component.html
  `)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-11"></a>Основной Модуль
  #### <a href="#04-11">Style 04-11</a>

.s-rule.do
  :marked
    **Рекомендуется** объеденять все классы которые используются только в одном месте в `CoreModule`. Упрощенный корневой `AppModule` импортирует `CoreModule` в качестве дерижера всего приложения.

.s-rule.do
  :marked
    **Рекомендуется** создать модуль функции `CoreModule` в папке `core` (например `app/core/core.module.ts` определяет `CoreModule`).

.s-rule.do
  :marked
    **Рекомендуется** размещать синглтон, чей экземпляр будет использоваться во всем приложении в `CoreModule`(например, `ExceptionService` и `LoggerService`).

.s-rule.do
  :marked
    **Рекомендуется** импортировать все модули которые необходимы ресурсам в `CoreModule` (например, `CommonModule` и `FormsModule`).

.s-why
  :marked
    **Почему?** `CoreModule` предоставляет один или более синглтон-сервисов. Angular registers the providers with the app root injector, making a singleton instance of each service available to any component that needs them, whether that component is eagerly or lazily loaded.

.s-why
  :marked
    **Почему?** `CoreModule` будет содержать сервисы синглтонов. When a lazy loaded module imports these, it will get a new instance and not the intended app-wide singleton.

.s-rule.do
  :marked
    **Рекомендуется** объеденять все gather application-wide, single use components in the `CoreModule`.
    Import it once (in the `AppModule`) when the app starts and never import it anywhere else. (e.g. `NavComponent` and `SpinnerComponent`).

.s-why
  :marked
    **Почему?** Real world apps can have several single-use components (e.g., spinners, message toasts, and modal dialogs) that appear only in the `AppComponent` template. 
    They are not imported elsewhere so they're not shared in that sense. 
    Yet they're too big and messy to leave loose in the root folder.

.s-rule.avoid
  :marked
    **Избегайте** импортирования `CoreModule` где-либо кроме как в `AppModule`.

.s-why
  :marked
    **Почему?** A lazily loaded feature module that directly imports the `CoreModule` will make its own copy of services and likely have undesireable results.

.s-why
  :marked
    **Почему?** An eagerly loaded feature module already has access to the `AppModule`'s injector, and thus the `CoreModule`'s services. 

.s-rule.do
  :marked
    **Do** export all symbols that from the `CoreModule` that the `AppModule` will import and make available for other feature modules to use.  

.s-why
  :marked
    **Почему?** `CoreModule` exists to make commonly used singleton services available for use in the many other modules.

.s-why.s-why-last
  :marked
    **Почему?** You want the entire app to use the one, singleton instance.
    You don't want each module to have its own separate instance of singleton services. 
    Yet there is a real danger of that happening accidentally if the `CoreModule` provides a service.


.filetree
  .file src
  .children
    .file app
    .children
      .file core
      .children
        .file core.module.ts
        .file logger.service.ts|spec.ts
        .file nav
        .children
          .file nav.component.ts|html|css|spec.ts
        .file spinner
        .children
          .file spinner.component.ts|html|css|spec.ts
          .file spinner.service.ts|spec.ts
      .file app.component.ts|html|css|spec.ts
    .file app.module.ts
    .file app-routing.module.ts
    .file main.ts
    .file index.html
    .file ...
:marked

+makeTabs(
  `
  style-guide/ts/04-11/app/app.module.ts,
  style-guide/ts/04-11/app/core/core.module.ts,
  style-guide/ts/04-11/app/core/logger.service.ts,
  style-guide/ts/04-11/app/core/nav/nav.component.ts,
  style-guide/ts/04-11/app/core/nav/nav.component.html,
  style-guide/ts/04-11/app/core/spinner/spinner.component.ts,
  style-guide/ts/04-11/app/core/spinner/spinner.component.html,
  style-guide/ts/04-11/app/core/spinner/spinner.service.ts
  `,
  `example,,,,,,,`,
  `
  app/app.module.ts,
  app/core/core.module.ts,
  app/core/logger.service.ts,
  app/core/nav/nav.component.ts,
  app/core/nav/nav.component.html,
  app/core/spinner/spinner.component.ts,
  app/core/spinner/spinner.component.html,
  app/core/spinner/spinner.service.ts
  `)
:marked

.l-sub-section
  :marked
    `AppModule` is a little smaller because many app/root classes have moved to other modules. 
    `AppModule` is stable because you will add future components and providers to other modules, not this one. 
    `AppModule` delegates to imported modules rather than doing work. 
    `AppModule` is focused on its main task, orchestrating the app as a whole.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-12"></a>Prevent Reimport of Core Module
  #### <a href="#04-12">Style 04-12</a>
  Only the root `AppModule` should import the `CoreModule`. 

.s-rule.do
  :marked
    **Do** guard against reimporting of `CoreModule` and fail fast by adding guard logic.

.s-why.s-why
  :marked
    **Почему?** Guards against reimporting of the `CoreModule`.

.s-why.s-why-last
  :marked
    **Почему?** Guards against creating multiple instances of assets intended to be singletons.
    
+makeTabs(
  `
  style-guide/ts/04-12/app/core/module-import-guard.ts,
  style-guide/ts/04-12/app/core/core.module.ts
  `,
  `,`,
  `
  app/core/module-import-guard.ts,
  app/core/core.module.ts
  `)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-13"></a>Отложено загружаемые папки
  #### <a href="#04-13">Style 04-13</a>
  Отдельный функционал приложения может быть *отложенно* загружен или *загружаться по требованию*, а не при запуске приложения.

.s-rule.do
  :marked
    **Do** put the contents of lazy loaded features in a *lazy loaded folder*.
    A typical *lazy loaded folder* contains a *routing component*, its child components, and their related assets and modules.

.s-why.s-why-last
  :marked
    **Почему?** Папка позволяет легко идентифицировать и изолировать содержимое функции.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="04-14"></a>Никогда напрямую не импортируйте отложенно загруженные папки
  #### <a href="#04-14">Style 04-14</a>

.s-rule.avoid
  :marked
    **Избегайте** allowing modules in sibling and parent folders to directly import a module in a *lazy loaded feature*.

.s-why.s-why-last
  :marked
    **Почему?** Directly importing and using a module will load it immediately when the intention is to load it on demand.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Компоненты

  ### <a id="05-02"></a>Component Selector Naming
  #### <a href="#05-02">Style 05-02</a>

.s-rule.do
  :marked
    **Рекомендуется** именовать селекторы элементов компонентов с использованием _регистра-c-тире_ или _шашлычный-регистр_.

.s-why.s-why-last
  :marked
    **Почему?** Сохраняет имена элементов в соответствии со спецификацией [Пользовательских элементов](https://www.w3.org/TR/custom-elements/).

+makeExample('style-guide/ts/05-02/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-02/app/heroes/shared/hero-button/hero-button.component.ts,
  style-guide/ts/05-02/app/app.component.html`,
  'example,',
  `app/heroes/shared/hero-button/hero-button.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-03"></a>Компоненты как Элементы
  #### <a href="#05-03">Style 05-03</a>

.s-rule.do
  :marked
    **Рекомендуется** определять компоненты как элементы через селектор.

.s-why
  :marked
    **Почему?** У компонентов есть шаблоны, содержащие HTML и необязательный  синтаксис шаблона Angular. Больше всего они связаны с размещения контента на странице, и поэтому более тесно связаны с элементами.

.s-why
  :marked
    **Почему?** Компонент представляет собой визуальный элемент на странице.
    Определение селектора как HTML-тег элемента согласуется с нативными HTML-элементами и WebComponents.

.s-why.s-why-last
  :marked
    **Почему?** Так становится легче распознать, что элемент является компонентом, а не директивой, просто посмотрев на HTML шаблон.

+makeExample('style-guide/ts/05-03/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-03/app/app.component.avoid.html', '', 'app/app.component.html')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-03/app/heroes/shared/hero-button/hero-button.component.ts,
  style-guide/ts/05-03/app/app.component.html`,
  'example,',
  `app/heroes/shared/hero-button/hero-button.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-04"></a>Извлечение шаблонов и стилей в отдельные файлы
  #### <a href="#05-04">Style 05-04</a>

.s-rule.do
  :marked
    **Рекомендуется** извлекать шаблоны и стили в отдельные файлы, если их длина превышает три строки.

.s-rule.do
  :marked
    **Рекомендуется** именовать файл шаблона `[component-name].component.html`, где [component-name] это имя компонента.

.s-rule.do
  :marked
    **Рекомендуется** именовать файл стиля`[component-name].component.css`, где [component-name]это имя компонента.

.s-why
  :marked
    **Почему?** Синтаксические подсказки для встроенных шаблонов в (*.js и *.ts) поддерживаются не всеми редакторами кода.

.s-why.s-why-last
  :marked
    **Почему?** Логика внутри файлов компонентов лучше прослеживается когда она не смешана со встроенными шаблонами и стилями.

+makeExample('style-guide/ts/05-04/app/heroes/heroes.component.avoid.ts', 'example', 'app/heroes/heroes.component.ts')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-04/app/heroes/heroes.component.ts,
  style-guide/ts/05-04/app/heroes/heroes.component.html,
  style-guide/ts/05-04/app/heroes/heroes.component.css`,
  'example,,',
  `app/heroes/heroes.component.ts,
  app/heroes/heroes.component.html,
  app/heroes/heroes.component.css`)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-12"></a>Инлайн декорирование свойств ввода и вывода
  #### <a href="#05-12">Style 05-12</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать `@Input` и `@Output` вместо `inputs` и `outputs` свойств 
    `@Directive и  `@Component` декораторов:

.s-rule.do
  :marked
    **Рекомендуется** помещать `@Input()` или `@Output()` в ту же строку, в которой находится свойство, которое они декорируют.

.s-why
  :marked
    **Почему?** Так проще определить какие свойства в классе являются Вводом, а какие Выводом.

.s-why
  :marked
    **Почему?** Если вам вдруг когда-либо понадобится переименовать свойство или событие связанное с 
    `@Input` или `@Output`, вы сможете это сделать в одном месте.

.s-why
  :marked
    **Почему?** Объявление метаданных прикрепленное к директиве короче и, следовательно, более удобочитаемо.

.s-why.s-why-last
  :marked
    **Почему?** Размещение декоратора на той же строке уменьшает количество кода и по-прежнему делает идентификацию свойства (ввод или вывод) простой.

+makeExample('style-guide/ts/05-12/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-12/app/heroes/shared/hero-button/hero-button.component.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-13"></a>Избегайте переименования вводов и выводов
  #### <a href="#05-13">Style 05-13</a>

.s-rule.avoid
  :marked
    **Избегайте** (по возможности) переименования вводов и выводов.

.s-why.s-why-last
  :marked
    **Почему?** Это может привести к путанице, когда выходные или входные свойства данной директивы наименованы по одному, но экспортируется иначе как публичный API.

+makeExample('style-guide/ts/05-13/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-13/app/app.component.avoid.html', '', 'app/app.component.html')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-13/app/heroes/shared/hero-button/hero-button.component.ts,
  style-guide/ts/05-13/app/app.component.html`,
  'example,',
  `app/heroes/shared/hero-button/hero-button.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-14"></a>Последовательность членов
  #### <a href="#05-14">Style 05-14</a>

.s-rule.do
  :marked
    **Рекомендуется** размещать свойства над методами.

.s-rule.do
  :marked
    **Рекомендуется** размещать private члены после public членов и сортировать их по алфавиту.

.s-why.s-why-last
  :marked
    **Почему?** Размещение членов в согласованной последовательности повышает читаемость
     кода и помогает мгновенно определить, какие члены компонента какую цель выполняют.
    

+makeExample('style-guide/ts/05-14/app/shared/toast/toast.component.avoid.ts', 'example', 'app/shared/toast/toast.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-14/app/shared/toast/toast.component.ts', 'example', 'app/shared/toast/toast.component.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-15"></a>Размещайте логику в Сервисах
  #### <a href="#05-14">Style 05-15</a>

.s-rule.do
  :marked
    **Рекомендуется** ограничивать логику в компоненте так, чтобы оставалась только необходимая для отображения. Вся остальная логика должна быть делегирована сервисам.

.s-rule.do
  :marked
    **Рекомендуется** размещать многократно используемую логику в сервисы и держать компоненты простыми и следить за тем, чтобы они выполняли только свое прямое назначение, не более.

.s-why
  :marked
    **Почему?** Логика может быть повторно использована несколькими компонентами при размещении внутри сервиса и при выставлении её наружу через функцию.

.s-why
  :marked
    **Почему?** Таким образом логику в сервисе проще изолировать в юнит-тесте, в то время как вызов логики в компоненте can be easily mocked.

.s-why
  :marked
    **Почему?** Это убирает зависимости и скрывает детали реализации от компонента.

.s-why.s-why-last
  :marked
    **Почему?** Это помогает сохранять компонент маленьким, опрятным, а также сохраняет направленность на выполнение одного определенного функционала.

+makeExample('style-guide/ts/05-15/app/heroes/hero-list/hero-list.component.avoid.ts', '', 'app/heroes/hero-list/hero-list.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-15/app/heroes/hero-list/hero-list.component.ts', 'example', 'app/heroes/hero-list/hero-list.component.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-16"></a>Не добавляйте префикс к свойствам вывода
  #### <a href="#05-16">Style 05-16</a>

.s-rule.do
  :marked
    **Рекомендуется** именовать события без префикса `on`.

.s-rule.do
  :marked
    **Рекомендуется** именовать методы обработчиков событийс префиксом `on` + имя события.

.s-why
  :marked
    **Почему?** Это совпадает со встроенными событиями, такими 'как нажатиие на кнопоку'.

.s-why.s-why-last
  :marked
    **Почему?** Angular позволяет использовать [альетрнативный синтаксис](template-syntax.html#binding-syntax) `on-*`. Если само событие начиналась с префикса `on` это приведет к тому, что имя выражения станет `on-onEvent`.

+makeExample('style-guide/ts/05-16/app/heroes/hero.component.avoid.ts', 'example', 'app/heroes/hero.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-16/app/app.component.avoid.html', '', 'app/app.component.html')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-16/app/heroes/hero.component.ts,
  style-guide/ts/05-16/app/app.component.html`,
  'example,',
  `app/heroes/hero.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="05-17"></a>Помещайте логику представления в компонент класса 
  #### <a href="#05-17">Style 05-17</a>

.s-rule.do
  :marked
    **Рекомендуется** размещать логику представления в компонент класса, а не в шаблон.

.s-why
  :marked
    **Почему?** Логика будет содержаться в одном месте (компонент класса ) вместо того, чтобы разделяться на две сущности.

.s-why.s-why-last
  :marked
    **Почему?** Сохраняя логику представления компонента в классе вместо шаблона улучшает тестируемость, упрощает поддержку и возможность её повтороного использования.

+makeExample('style-guide/ts/05-17/app/heroes/hero-list/hero-list.component.avoid.ts', 'example', 'app/heroes/hero-list/hero-list.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-17/app/heroes/hero-list/hero-list.component.ts', 'example', 'app/heroes/hero-list/hero-list.component.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Directives

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="06-01"></a>Use Directives to Enhance an Existing Element
  #### <a href="#06-01">Style 06-01</a>

.s-rule.do
  :marked
    **Do** use attribute directives when you have presentation logic without a template.

.s-why
  :marked
    **Почему?** Attributes directives don't have an associated template.

.s-why.s-why-last
  :marked
    **Почему?** An element may have more than one attribute directive applied.

+makeExample('style-guide/ts/06-01/app/shared/highlight.directive.ts', 'example', 'app/shared/highlight.directive.ts')
:marked

+makeExample('style-guide/ts/06-01/app/app.component.html', null, 'app/app.component.html')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="06-03"></a>Используйте HostListener и HostBinding декораторы классов
  #### <a href="#06-03">Style 06-03</a>

.s-rule.consider
  :marked
    **Постарайтесь** использовать `@HostListener` и `@HostBinding` вместо 
    свойства `host` декораторов `@Directive` и `@Component`.

.s-rule.do
  :marked
    **Рекомендуется** быть последовательным в своих решениях. Следуйте одному выбраному методу декорирования.

.s-why.s-why-last
  :marked
    **Почему?** Свойство, связанное с `@HostBinding` или метод, связанный
     с `@HostListener` может быть изменен только в одном месте - в классе директивы.
    Если вы используете свойство метаданных `host`, необходимо изменить как объявление 
    свойства внутри контроллера, а также метаданные, связанные с директивой.

+makeExample('style-guide/ts/06-03/app/shared/validator.directive.ts', '', 'app/shared/validator.directive.ts')
:marked
  Сравните с менее предпочтительной альтернативой `host` метаданными.

.s-why.s-why-last
  :marked
    **Почему?** `host` метаданные - всего лишь один термин, который необходимо запомнить, к тому же, они не требуют дополнительных импортов ES.

+makeExample('style-guide/ts/06-03/app/shared/validator2.directive.ts', '', 'app/shared/validator2.directive.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Services

  ### <a id="07-01"></a>Сервисы это синглтоны внутри инжектора
  #### <a href="#07-01">Style 07-01</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать сервисы как синглтоны внутри одного инжектора. Используйте их для для обмена данными и функциональом.

.s-why
  :marked
    **Почему?** Сервисы идеально подходят для совместного использования методов по всей области функционала приложения.

.s-why.s-why-last
  :marked
    **Почему?** Сервисы идеально подходят для обмена данными с сохранением состояния в оперативной памяти.

+makeExample('style-guide/ts/07-01/app/heroes/shared/hero.service.ts', 'example', 'app/heroes/shared/hero.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="07-02"></a>Принцип единой ответственности
  #### <a href="#07-02">Style 07-02</a>

.s-rule.do
  :marked
    **Рекомендуется** создавать сервисы с единой ответственностью, которые инкапсулируются своим контекстом.

.s-rule.do
  :marked
    **Рекомендуется** создавать новый сервис, когда старый начинает выполнять больше, чем одну функцию.

.s-why
  :marked
    **Почему?** Когда сервис имеет несколько функций, становится тяжелее его тестировать.

.s-why.s-why-last
  :marked
    **Почему?** Когда у сервиса есть несколько функций, каждый компонент или сервис, который его инжектит начинает нести вес их всех.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="07-03"></a>Предоставление Сервисов
  #### <a href="#07-03">Style 07-03</a>

.s-rule.do
  :marked
    **Рекомендуется** предоставлять сервисы Angular инжекторам в самом высоком по иерархии компоненте, где они будут доступны для всех.

.s-why
  :marked
    **Почему?** Инжектры в Angular иерархичны.

.s-why
  :marked
    **Почему?** При предоставлении сервиса компоненту верхнего уровня, этот инстанс является общим и доступным для всех дочерних компонентов этого  компонента верхнего уровня.

.s-why
  :marked
    **Почему?** Это идеальный вариант, когда сервис предоставляет доступ к методам или состояниям

.s-why.s-why-last
  :marked
    **Почему?** Это не идеальное решение, когда двум разным компонентам нужны разные инстансы сервиса. В этом случае, было бы лучше предоставить сервис на уровне компонентов, которые нуждаются в новом и отдельном инстансе.

+makeTabs(
  `style-guide/ts/07-03/app/app.component.ts,
  style-guide/ts/07-03/app/heroes/hero-list/hero-list.component.ts`,
  '',
  `app/app.component.ts,
  app/heroes/hero-list/hero-list.component.ts`)
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="07-04"></a>Используйте декоратор класса @Injectable() 
  #### <a href="#07-04">Style 07-04</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать декоратор класса `@Injectable` вместо `@Inject` при использовании типов, как токенов для зависимостей сервиса.

.s-why
  :marked
    **Почему?** Механизм Angular DI разрешает все зависимости служб на основе их типов, объявленных с помощью конструкторов сервисов.

.s-why.s-why-last
  :marked
    **Почему?** Когда сервис принимает только зависимости, связанные с типом токенов,  синтаксис `@Injectable()` гораздо менее сжат по сравнению с использованием `@Inject()` на каждый отдельный параметр конструктора.

+makeExample('style-guide/ts/07-04/app/heroes/shared/hero-arena.service.avoid.ts', 'example', 'app/heroes/shared/hero-arena.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/07-04/app/heroes/shared/hero-arena.service.ts', 'example', 'app/heroes/shared/hero-arena.service.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Data Services

  ### <a id="08-01"></a>Раздельные вызовы данных
  #### <a href="#08-01">Style 08-01</a>

.s-rule.do
  :marked
    **Рекомендуется** реорганизовать логику для создания операций с данными и взаимодействия с данными сервиса.

.s-rule.do
  :marked
    **Рекомендуется** реализовывать сервисы данных так, чтобы они отвечали за XHR вызовы, локальное хранилище, хранение данных в памяти, или любые другие операции с данными.

.s-why
  :marked
    **Почему?** Задача компонента - предоставление и сбор информации для view. View не должно волновать, как он получает данные, необходимо только знать, к кому за ней обратиться. Разделение сервисов данных перемещает логику services moves the logic on how to get it to the data service, and lets the component be simpler and more focused on the view.

.s-why
  :marked
    **Почему?** Это облегчает тестирование (макета или готовое приложение) вызовов данных при тестировании компонента, использующего сервис данных. 

.s-why.s-why-last
  :marked
    **Почему?** Реализация сервиса данных может иметь очень специфический код для обработки хранилища данных. Он может включать в себя хэдеры, инструкции для обработки данных, или другие сервисы, такие как `http`. Отделение логики в отдельный сервис данных инкапсулирует эту логику в одном месте, скрывая реализацию от внешних потребителей (возможно, компонент), а также облегчает изменение реализации.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Хуки жизненного цикла

  Используйте хуки жизненного цикла чтобы подключиться к важным событиям предоставляемым Angular.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="09-01"></a>Реализовывайте хуки жизненного цикла интерфейсов
  #### <a href="#09-01">Style 09-01</a>

.s-rule.do
  :marked
    **Рекомендуется** реализовывать хуки жизненного цикла интерфейсов.

.s-why.s-why-last
  :marked
    **Почему?** Строго типизированный метод сигнатур.
    Компилятор и редактор могут указывать на опечатки.

+makeExample('style-guide/ts/09-01/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/09-01/app/heroes/shared/hero-button/hero-button.component.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')
:marked

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ## Appendix

  Полезные инструменты и советы для Angular.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="A-01"></a>Codelyzer
  #### <a href="#A-01">Style A-01</a>

.s-rule.do
  :marked
    **Рекомендуется** пользоваться [codelyzer](https://www.npmjs.com/package/codelyzer) чтобы было проще следовать этому руководству.

.s-rule.consider
  :marked
    **Постарайтесь** подстроить правила в codelyzer под свои нужды.

a(href="#toc") Вернуться наверх

.l-main-section
:marked
  ### <a id="A-02"></a>Шаблоны файлов и Сниппеты
  #### <a href="#A-02">Style A-02</a>

.s-rule.do
  :marked
    **Рекомендуется** использовать шаблоны файлов или сниппеты, чтобы было проще следовать единому стилю и шаблонам кода. Вот шаблоны и/или фрагменты кода для некоторых из IDE.

.s-rule.consider
  :marked
    **Постарайтесь** использовать [сниппеты](https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2) для [Visual Studio Code](https://code.visualstudio.com/) которые следуют этим стилям и рекомендациям.

    <a href="https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2">
      <img src="https://github.com/johnpapa/vscode-angular2-snippets/raw/master/images/use-extension.gif" width="80%" alt="Use Extension">
    </a>  

    **Постарайтесь** использовать [сниппеты](https://atom.io/packages/angular-2-typescript-snippets) для [Atom](https://atom.io/) которые следуют этим стилям и рекомендациям.

    **Постарайтесь** использовать [сниппеты](https://github.com/orizens/sublime-angular2-snippets) для [Sublime Text](http://www.sublimetext.com/) которые следуют этим стилям и рекомендациям.

    **Постарайтесь** использовать [сниппеты](https://github.com/mhartington/vim-angular2-snippets) для [Vim](http://www.vim.org/) которые следуют этим стилям и рекомендациям.

a(href="#toc") Вернуться наверх
