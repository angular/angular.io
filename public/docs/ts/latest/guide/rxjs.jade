block includes
  include ../_util-fns

:marked
  **Observables** provided by the Reactive Extensions for Javascript (RxJS) library provide applications with an extensive API
  for handling asynchronous and event-based values produced over time.

  An application is made up of many different streams of information. Whether it be user input into
  a form, navigating from one route another, making an HTTP request to fetch some data, updating the application view with
  new data as its received, or many other examples, each of these events happen over time. Observables provide a interface to
  handle the many different sources of events and help to transform these events as they flow throughout an application.

  This guide will serve as an introductory chapter to Observables, common uses cases for Observables in an Angular application
  and how Observables are used and provided by the Angular framework.

  ## Table of Contents
  * [The Observable](#definition "")
  * [Observables and Promises](#observables-vs-promises "")
  * [Framework APIs](#apis "")
  * [Error Handling](#error-handling "")
  * [Further Reading](#reading "")

h3#definition The Observable: a function at its core

:marked
  An Observable, simply put, is a specific type of function with a specific purpose. It’s a function that accepts an `Observer` to produce values and
  returns a function for cancellation. It represents an action that can be performed. This action may be performed right now, or at some point
  in the future. An action can be anything, from simply "return a constant", "make an HTTP request" or "navigate to another page".

:marked
  TODO Overview of basic principles

  * Subscribe/unsubscribe
  * Observer - next/error/complete

  Link to official RxJS docs

h3#observables-vs-promises Observables and Promises: More different than alike

:marked
  RxJS and Observables have been around for a long time, and they aren't the first concept of handling asynchronous events. Before Observables became more prevalent,
  the `Promise` was the primary way of handling asynchronous events. Promises and Observables share some similarities as they both handle asynchronous events,
  both implement a function to handle execution and error handling, but they are more different then alike.

  ***Promises***
  * Always eagerly evaluated
  * Produce a value/error once
  * Cannot be composed
  * Are always resolved/rejected asynchronously
  * Are always multicast to multiple receivers

  ***Observables***
  * Can be evaluated lazily
  * Produce multiple values/errors
  * Can be composed
  * Resolve synchronously/asynchronously
  * Multicast when needed using a Subject

  One of the strengths of Observables is producing and handling values over time, which is something a Promise wasn't designed to do. Observables also provide mechanisms
  for easy cancellation, retrying upon failure and transformations. Observables include a rich library of operators, along with the extensibility to provide a more powerful
  tool to handle the various streams of events in an application. So does this mean Promises are no longer needed? Absolutely not. Promises will continue to serve a purpose as
  the right tool for the job in some situations.

h3#managing-subscriptions Managing Subscriptions

:marked
  Observables like any other instance use resources and those resources add to the overall resources used in your application. Observables
  provide a `Subscription` for each `Subscriber` of the Observable that comes with a way to _unsubscribe_ or clean up any resources used
  while listening for values produced by the Observable. We'll look at a simple example of how to unsubscribe from and Observable once
  its no longer needed.

  We'll create a component named `HeroCounterComponent` that will do a simple task of increasing a total of heroes. We'll simulate
  that this hero counter is running as long as the component is active an in view. Once the component is destroyed, we no longer
  want to listen for any changes coming from the Observable counter.

  // Example of hero counter

  Since you know Angular has lifecycle hooks, we can use the `ngOnDestroy` lifecycle hook to unsubscribe from this Observable counter
  and clean up its resources.

  // Example of unsubscribe

  Disposing of a single subscription when your component is destroyed is very manageable, but as you use more Observables managing
  multiple subscriptions can get unwieldy. We can use a better approach to managing subscriptions. Observables have `operators`
  that can cancel other observable streams. We can end multiple observable streams with one observable using the `takeUntil` operator.
  The `takeUntil` operator takes an Observable and when that observable emits a value, the Observables that are producing values will
  stop emitting values and complete.

  Let's update our hero counter example to use the `takeUntil` operator. In order to use the `takeUntil` operator, we must add it
  to the base Observable prototype. We'll import the operator which will add it to the observable.

  // Example of import for takeUntil operator

  Since we need an Observable that emits a value, we can use a `Subject`. We'll cover streams you can create on your own later in
  the chapter, as a `Subject` is a special type of Observable. We'll create a `destroy$` observable using the Subject.

  // Example of new Subject()

  Now we can add the `takeUntil` operator to our Observable and once the `destroy$` Observable produces a value,
  the counter Observable will complete and will no longer produce any values.

  // example of destroy$ in ngOnDestroy

  This approach scales and you can use a single observable to trigger completion across multiple subscriptions.

+makeExcerpt('app/hero-counter.component.ts', '')

h3#async-pipe Async Pipe: Less is more
:marked
  You can manage Observables imperatively through manually subscribing and unsubscribing when needed but you can also
  manage them declaratively in our templates using the `Async Pipe`. The async pipe can also take care of our Subscription
  management, as it can take an Observable or a Promise, listen for its emitted values and will destroy its subscriptions
  with the disposing of the component. This allows us to use Observables with less boilerplate and that's always a good thing.

  You will create another component that displays a list of heroes using these two options. Our component will retrieve a list of
  Heroes from our `HeroService` and subscribe to set them to a variable in the component.

+makeExcerpt('app/hero-list.component.1.ts (subscribe)', '')

:marked
  As you can see, we called and subscribed to the `getHeroes` function in our HeroService which returned an Observable provided
  by the HTTP client and the `ngFor` directive is set up to display the heroes. In the `subscribe` function we assign the returned heroes to the heroes variable.
  Here you are only assigning the `heroes` value to bind it to our template. The `Async Pipe` lets us skip the manual subscription,
  as it will handle this for you. The updated template is below.

+makeExcerpt('app/hero-list.component.ts (async pipe)', '')

  When your component is rendered, the async pipe will subscribe to the Observable to listen for emitted values. Once the values
  are produced it will wire those values to the same `ngFor` directive. If you were to initiate another sequence of heroes
  the pipe would handle updated the retrieved values along with destroying the Observable subscription once the component is destroyed.

h3#sharing-data Sharing data with a stream
:marked
  As you build out your Angular application, you will start sharing data between multiple components. These components may span across multiple routes
  or application views in your application hierarchy. This allows you to centralize where that data comes from and allow multiple recipients of
  that data to handle it according to their needs. With Observables, you can push changes to this data and notify all of the subscribers so they can react
  to it.

  You will need a simple message bus provided by a service to aggregate events to share across multiple components. The name of your service will be
  aptly named `EventAggregatorService`. Since you want your Observable subscribes to all get the "latest" value from the stream, you'll use a `BehaviorSubject`.

  A `BehaviorSubject` is a special type of Observable that has a memory of the current value or the last value produced, so each new subscriber of this Observable
  will get its current value immediately.

  You'll import the `Injectable` decorator from `@angular/core` and the `BehaviorSubject` from the RxJS library to use it in the service.

+makeExcerpt('app/event-aggregator.service.ts (event interface)', 'imports')

:marked
   You'll need an interface to provide consumers with to add messages to the event log.

+makeExcerpt('app/event-aggregator.service.ts (event interface)', 'event-interface')

:marked
   Next, you'll create your service. Since a `BehaviorSubject` keeps the latest value for subscribers, you'll need to provide it with an initial value also.
   There is the `add` method for adding additional events to the log and `clear` method for clearing the message. You'll notice that the `notify` method
   calls the `events$.next` method to notify the subscribers of a new value pushed to the stream.

+makeExcerpt('app/event-aggregator.service.ts', '')

:marked
  Now that you have a central place to collect events, you can inject the `EventAggregatorService` throughout your application. In order to display
  the message log, you'll create a simple message component to display the aggregated events. You can use the `Async Pipe` here also to wire up the
  stream to the template.

+makeExcerpt('app/message-log.component.ts (message log component)', '')

:marked
   As with other services, you'll import the `EventAggregatorService` and `MessageLogComponent` and add it to the `AppModule` providers and declarations
   arrays respectively.

+makeExcerpt('app/app.module.ts', '')

:marked
  To see your message bus in action, you'll import and inject the `EventAggregatorService` in the `AppComponent` and add an event when the Application
  starts and add the `message-log` component to the `AppComponent` template.

+makeExcerpt('app/app.component.ts (message log)', '')

h3#error-handling Error Handling
:marked

+makeExcerpt('app/api-error-handler.service.ts', '')

h3#framework-apis Framework APIs: Angular-provided streams
:marked
  Angular makes use of Observables internally and externally through its APIs template syntax using the Async pipe, user input
  with Reactive or Model-Driven Forms, making external requests using Http and route information with the Router.
  By using Observables underneath, these APIs provide a consistent way for you to use and become more comfortable
  with using Observables in your application to handle your streams of data that are produced over time.
  Another major advantage of the streams provided by Angular is that they are managed for you,
  so no need to unsubscribe to clean up subscriptions.

  Http

  Making external requests from our application is a very common action in every application. You make a request,
  handle the success or failure of that request and wait for the request to be made again. Sometimes it’s not as
  simple as that as you need the be able to retry, cancel or delay requests. Being efficient with requests to save
  on data transferred is vital when every byte counts. HTTP requests are not a one-off action as many elements of
  your application is driven by external data. The Http client in Angular is built on top of Observables which
  provide the ability to handle one single request or multiple requests seamlessly, along with retrying and
  cancellations of requests.

  Example: Use hero service to make a request, make it fail to show retries, conditional retry.
+makeExcerpt('app/hero-list.component.1.ts', '')

:marked
  Async Pipe

  As we’ve talked about previously, Observables must be subscribed to in order to handle the data they produce,
  and must be unsubscribed from in order to clean up the resources they have used. You’ve gone through how to
  subscribe to an Observable, get its data and provide that data through a variable in your class. There is also
  a built-in pipe available for use with template syntax to manage Observable subscriptions called the Async Pipe.
  When used in a template, the async pipe will subscribe to the Observable or evaluate a Promise, receive its
  emitted values and dispose of its subscription once the component is destroyed. The pipe also ties into Change Detection,
  so that when new values are produced, the component is marked for detection in order to determine whether it’s changes
  need to be reflected in your user interface. This is useful as it reduces the amount of boilerplate you need when setting
  up data to be fetched and provided to your template. We’ll learn later about cases where using an async pipe is beneficial
  versus managing your own subscription manually.

  Example: Fetching heroes using a service, subscribing/unsubscribing manually then removing the subscription and delegating responsibility to the async pipe. Another example would be showing hero details with multiple async pipes, but instead using a single subscription.
+makeExcerpt('app/hero-detail.component.ts', '')

:marked
  Forms
  With many applications, user input is required to initiate or complete an action. Whether it be logging in or filling out
  an information page, user data is another stream that needs to be handled. In contrast to template-driven forms where the
  responsibility is on the developer to gather the pieces of data from the form, the model-driven/Reactive forms uses
  Observables to easily provide a continuous stream of user input. By using the reactive approach, our form will be ready
  to handle user input streams from form fields, as well as provide that form data seamlessly to another stream for
  processing.

  Example: Simple form that displays form status/value changes over time. Also displays creating an Observable from an existing event. valueChanges on individual field/entire form

  Router

  The browser URL is another stream of information. It provides you with a canonical link to the application view you are
  displaying at any given moment, along with information about what data to display. The Angular Router uses the browser URL
  to provide you with multiple streams that hook into the navigation process, URL data provided through your route
  configuration, parameters provided for context and path information. These pieces of data are provided by the Router
  through Observables, since we are certain that these streams happen in a continuous fashion as a user navigates throughout
  your Angular application.

  Router Observables: Events, Parameters, Data, URL Segments

  Example: Use router events to build a small loading service and component.
+makeExcerpt('app/loading.service.ts', '')
+makeExcerpt('app/loading.component.ts', '')

h3#integration Stream Integration
:marked
  The Observables provided by these area can be used together. The same set of functionality and extensibility can be combined together in a very powerful and
  practical way. In order to demonstrate how these work together, you’re going to build a hero search component. Let’s start by gathering some requirements about
  what your typeahead will need.

  * Take input from the user
  * Make a search based on that input
  * Only search when the user has changed the search terms
  * Cancel any in-progress requests if you user initiates a new search
  * Only make a request after the user hasn’t interacted within a certain time frame
  * Display search results
  * Sync the user’s search terms in the browser URL

  Example: Hero search typeahead component
+makeExcerpt('app/hero-search.component.ts', '')

h3#further-reading Further Reading
:marked
  TODO
