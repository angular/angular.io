include ../_util-fns

:marked
  One of the defining features of a single page application is its manipulation
  of the DOM tree. Instead of serving a whole new page every time a user
  navigates, whole sections of the DOM appear and disappear according
  to the application state. 
  
  In this chapter we'll to look at how Angular
  manipulates the DOM and how we can do it ourselves in our own directives.
  
  After learning about directives, we're going to turn our attention to how 
  components can also share structure.

  - [What are structural directives?](#definition)
  - [NgIf Case Study](#ng-if)
  - [The &lt;template> tag](#template)
  - [The asterisk (\*) effect](#asterisk)
  - [Make a structural directive](#unless)
  - [What are structural components?](#what-are-structural-components-)
  - [Heroes Dashboard](#heroes-dashboard)
  - [A tale of three DOMs](#a-tale-of-three-doms)
  - [Element projection](#element-projection)
  - [Templates for components](#templates-for-components)
  - [Components as first-class citizens](#components-as-first-class-citizens)
  - [Finished dashboard](#finished-dashboard)
  - [Wrapping up](#wrapping-up)

  [Live example](/resources/live-examples/structural-directives/ts/plnkr.html)

<a id="definition"></a>
.l-main-section
:marked
  ## What are structural directives?

  There are three kinds of Angular directives:
  1. Components
  1. Attribute directives
  1. Structural directives

  The *Component* is really a directive with a template.
  It's the most common of the three directives and we write lots of them as we build our application.

  The [*Attribute* directive](attribute-directives.html) changes the appearance or behavior of an element.
  The built-in [NgStyle](template-syntax.html#ngStyle) directive, for example,
  can change several element styles at the same time.
  We can use it to render text bold, italic, and lime green by binding to a
  component property that requests such a sickening result.

  A *Structural* directive changes the DOM layout by adding and removing DOM elements.
  We've seen three of the built-in structural directives in other chapters: [ngIf](template-syntax.html#ngIf),
  [ngSwitch](template-syntax.html#ngSwitch) and [ngFor](template-syntax.html#ngFor).

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'structural-directives')(format=".")


<a id="ng-if"></a>
.l-main-section
:marked
  ## NgIf Case Study

  Letâ€™s focus on `ngIf`. It's a great example of a structural
  directive: it takes a boolean and makes an entire chunk of DOM appear
  or disappear.

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngIf')(format=".")

:marked
  The `ngIf` directive does not hide the element.
  Using browser developer tools we can see that, when the condition is true, the top
  paragraph is in the DOM and the bottom disused paragraph is completely
  absent from the DOM! In its place are empty `<script>` tags.

figure.image-display
  img(src='/resources/images/devguide/structural-directives/element-not-in-dom.png' alt="element not in dom")

:marked
  ### Why *remove* rather than *hide*?
  We could hide the unwanted paragraph by setting its css `display` style to `none`.
  The element would remain in the DOM while invisible. Instead we removed it with `ngIf`.

  The difference matters. When we hide an element,
  the component's behavior continues.
  It remains attached to its DOM element. It continues to listen to events.
  Angular keeps checking for changes that could affect data bindings.
  Whatever the component was doing it keeps doing.

  Although invisible, the component &mdash; and all of its descendent components &mdash;
  tie up resources that might be more useful elsewhere.
  The performance and memory burden can be substantial and the user may not benefit at all.

  On the positive side, showing the element again is very quick.
  The component's previous state is preserved and ready to display.
  The component doesn't re-initialize &mdash; an operation that could be expensive.

  `ngIf` is different.
  Setting `ngIf` to false **does** affect the component's resource consumption.
  Angular removes the element from DOM, stops change detection for the associated component,
  detaches it from DOM events (the attachments that it made) and destroys the component.
  The component can be garbage-collected (we hope) and free up memory.

  Components often have child components which themselves have children.
  All of them are destroyed when `ngIf` destroys the common ancestor.
  This cleanup effort is usually a good thing.

  Of course it isn't *always* a good thing.
  It might be a bad thing if we need that particular component again soon.

  The component's state might be expensive to re-construct.
  When `ngIf` becomes `true` again, Angular recreates the component and its subtree.
  Angular runs every component's initialization logic again. That could be expensive ... as when
  a component re-fetches data that had been in memory just moments ago.
.l-sub-section
  :marked
    *Design thought*: minimize initialization effort and consider caching state in a
    companion service.
:marked
  Although there are pros and cons to each approach,
  in general it is best to use `ngIf` to remove unwanted components rather than
  hide them.

  **These same considerations apply to every structural directive, whether built-in or custom.**
  We should ask ourselves &mdash; and the users of our directives &mdash; to think carefully
  about the consequences of adding and removing elements and of creating and destroying components.

  Let's see these dynamics at work. For fun, we'll stack the deck *against*
  our recommendation and consider a component called `heavy-loader` that
  ***pretends*** to load a ton of data when initialized.

  We'll display two instances of the component.  We toggle the visibility of the first one with CSS.
  We toggle the second into and out of the DOM with `ngIf`.

+makeTabs(
    `structural-directives/ts/app/structural-directives.component.html,
    structural-directives/ts/app/heavy-loader.component.ts`,
    'message-log,',
    'template excerpt, heavy-loader.component.ts')

:marked
  We also log when a component is created or destroyed
  using the built-in `ngOnInit` and `ngOnDestroy` [lifecycle hooks](lifecycle-hooks.html).
  Here it is in action:

figure.image-display
  img(src='/resources/images/devguide/structural-directives/heavy-loader-toggle.gif' alt="heavy loader toggle")

:marked
  Both components are in the DOM at the start.
  First we toggle the component's visibility repeatedly. The component never leaves the DOM.
  When visible it's always the same instance and the log is quiet.

  Then we toggle the second component with `ngIf`.
  We create a new instance every time and the log shows that we're paying
  a heavy price to create and destroy it.

  If we really expected to "wink" the component like this, toggling visibility would be the better choice.
  In most UIs, when we "close" a component we're unlikely see it again for a long time, if ever.
  The `ngIf` would be preferred in that case.

<a id="template"></a>
.l-main-section
:marked
  ## The *&lt;template>* tag

  Structural directives, like `ngIf`, do their magic by using the
  [HTML 5 template tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template).

  Outside of an Angular app, the `<template>` tag's default CSS `display` property is `none`.
  It's contents are ***invisible*** within
  a hidden [document fragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment).

  Inside of an app, Angular ***removes*** the`<template>` tags and their children.
  The contents are gone &mdash; but not forgotten as we'll see soon.

  We can confirm these effects by wrapping the middle "hip" of the phrase "Hip! Hip! Hooray!" within a `<template>` tag.
+makeExample('structural-directives/ts/app/structural-directives.component.html', 'template-tag')(format=".")
:marked
  The display is a 'Hip!' short of perfect enthusiasm. The DOM effects are different when Angular is control.
figure.image-display
  img(src='/resources/images/devguide/structural-directives/template-in-out-of-a2.png' alt="template outside angular")

:marked
  Evidently Angular replaces the `<template>` tag and its contents with empty `<script>` tags.
  That's just its default behavior.
  It can do something different as we saw when applying a variety of `ngSwitch` directives to `<template>` tags:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngSwitch')(format=".")
:marked
  When one of those `ngSwitch` conditions is true, Angular inserts the template's content into the DOM.

  What does this have to do with `ngIf` and `ngFor`?  We didn't use a `<template>` tag with those directives.

<a id="asterisk"></a>
.l-main-section
:marked
  ## The asterisk (\*) effect
  Here are those directives again. See the difference?

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'asterisk')(format=".")
:marked
  We're prefixing these directive names with an asterisk (\*).

  The asterisk is "syntactic sugar". It simplifies `ngIf` and `ngFor` for both the writer and the reader.
  Under the hood, Angular replaces the asterisk version with a more verbose `<template>` form.

  The next two `ngIf` examples are effectively the same and we may write in either style:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngIf-template')(format=".")

:marked
  Most of us would rather write in style (A).

  It's worth knowing that Angular expands style (A) into style (B).
  It moves the paragraph and its contents inside a `<template>` tag.
  It moves the directive up to the `<template>` tag where it becomes a property binding,
  surrounded in square brackets. The boolean value of the host component's `condition` property
  determines whether the templated content is displayed or not.

  Angular transforms `*ngFor` in a similar manner:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngFor-template')(format=".")
:marked
  The basic pattern is the same:&nbsp; create a `<template>`, relocate the content,
  and move the directive onto the `<template>`.

  There are extra nuances stemming from
  Angular's [ngFor micro-syntax](template-syntax.html#ngfor-micro-syntax) which expands
  into an additional `ngForOf` property binding (the iterable) and
  the `#hero` [local template variable](template-syntax.html#local-vars)
  (the current item in each iteration).

<a id="unless"></a>
.l-main-section
:marked
  ## Make a structural directive
  Let's write our own structural directive, an `Unless` directive, the not-so-evil twin of `ngIf`.

  Unlike `ngIf` which displays the template content when `true`,
  our directive displays the content when the condition is ***false***.

:marked
  Creating a directive is similar to creating a component.
  * import the `Directive` decorator.

  * add a CSS **attribute selector** (in brackets) that identifies our directive.

  * specify the name of the public `input` property for binding
  (typically the name of the directive itself).

  * apply the decorator to our implementation class.

  Here is how we begin:

+makeExample('structural-directives/ts/app/unless.directive.ts', 'unless-declaration', 'unless.directive.ts (excerpt)')(format=".")
.l-sub-section
  :marked
    ### Selector brackets [&nbsp;]
    The CSS syntax for selecting an attribute is a name in square brackets.
    We surround our directive name in square brackets. See *Directive configuration* on the
    [cheatsheet](cheatsheet.html).

    ### Selector name prefixes

    We recommend picking a selector name with a prefix to ensure
    that it cannot conflict with any standard HTML attribute, now or in the future.

    We do **not** prefix our `unless` directive name with **`ng`**.
    That prefix belongs to Angular and
    we don't want to confuse our directives with their directives.

    Our prefix is `my`.
:marked
  We'll need access to the template *and* something that can render its contents.
  We access the template with a `TemplateRef`.  The renderer is a `ViewContainerRef`.
  We inject both into our constructor as private variables.

+makeExample('structural-directives/ts/app/unless.directive.ts', 'unless-constructor')(format=".")

:marked
  The consumer of our directive will bind a `true` | `false` value to our directive's `myUnless` input property.
  The directive adds or removes the template based on that value.

  Let's add the `myUnless` property now as a setter-only
  [definedProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).

+makeExample('structural-directives/ts/app/unless.directive.ts', 'unless-set')(format=".")
.l-sub-section
  :marked
    The `@Input()` annotation marks this property as an input for the directive.
:marked
  Nothing fancy here: if the condition is false,
  we render the template, otherwise we clear the element content.

  The end result should look like below:

+makeExample('structural-directives/ts/app/unless.directive.ts', null, 'unless.directive.ts')

:marked
  Now we add it to the `directives`array of the host component and try it.
  First we add some test HTML to the template:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'myUnless')(format=".")
:marked
  We run it and it behaves as expected, doing the opposite of `ngIf`.
  When `condition` is `true`, the top paragraph is removed (replaced by `<script>` tags) and the bottom paragraph appears.
figure.image-display
  img(src='/resources/images/devguide/structural-directives/myUnless-is-true.png' alt="myUnless is true" )

:marked
  Our `myUnless` directive is dead simple. Surely we left something out.
  Surely `ngIf` is more complex?

  [Look at the source code](https://github.com/angular/angular/blob/master/modules/angular2/src/common/directives/ng_if.ts).
  It's well documented and we shouldn't be shy
  about consulting the source when we want to know how something works.

  `ngIf` isn't much different! There are a few
  additional checks to improve performance (don't clear or recreate the
  view unless necessary) but otherwise it's much the same.

.l-main-section
:marked
  ## The code thus far
  Here is the pertinent source for what we've seen.

+makeTabs(`
  structural-directives/ts/app/unless.directive.ts,
  structural-directives/ts/app/heavy-loader.component.ts,
  structural-directives/ts/app/structural-directives.component.ts,
  structural-directives/ts/app/structural-directives.component.html
  `,
  null,
  `unless.directive.ts,
   heavy-loader.component.ts,
   structural-directives.component.ts,
   structural-directives.component.html
   `)
:marked
  We learned that we can manipulate our HTML layout with
  structural directives like `ngFor` and `ngIf` and we
  wrote our own structural directive, `myUnless`, to do something similar.

  Angular offers more sophisticated techniques for managing layout
  such as *structural components* that can take external content
  and incorporate that content within their own templates.
  Tab and tab pane controls are good examples.  

.l-main-section  
:marked
  ## What are structural components?
  
  We've seen how a structural directive can use a template to add and remove template content from the DOM.
  We can do more. We can incorporate the developers content *within our directive's own template*.
  Let's see an example.
  
  Usually, when we add a component's tags to a template,
  Angular discards everything between our element's opening tag and its closing tag.
  Consider this simple component.

+makeExample('structural-directives/ts/app/my-component.component.ts')(format=".")
:marked
  We apply it in a parent template in the usual way:
+makeExample('structural-directives/ts/app/my-component.component.html', 'my-component-1')(format=".")
:marked
  Angular displays the templated paragraph as we expect it should. The DOM looks like this:
figure.image-display
  img(src='/resources/images/devguide/structural-directives/my-component-content.png' alt="my-component content" width="270")
:marked
  We can influence the component by binding to it.
+makeExample('structural-directives/ts/app/my-component.component.html', 'my-component-2')(format=".")
figure.image-display
  img(src='/resources/images/devguide/structural-directives/my-component-content-2.png' alt="my-component content #2" width="250")
:marked
  That's cool. But it's a limited, programmatic form of customization. 
  It doesn't give the UI designer the flexibility
  to put arbitrary HTML on the page that the component can manipulate and redisplay. 
    
  Suppose we *had* some HTML that we want the component to redisplay.
  Logically, we'd put that HTML between our component tags. What happens when we do this?

+makeExample('structural-directives/ts/app/my-component.component.html', 'my-component-3')(format=".")
:marked
  Too bad! Angular discards everything between the `my-component` tags and renders the component template
  as if nothing happened. We're back to this:

figure.image-display
  img(src='/resources/images/devguide/structural-directives/my-component-content.png' alt="my-component content" width="270")
:marked
  That is not what we intended. We want Angular to **incorporate** the material between the tags
  *within* the component's template. 
  
  This is a powerful idea. If we could do it, we could create reusable components that
  manipulate *external* DOM elements, oblivious to their representation. We could also provide
  a component with a template with which to render certain data within itself.  
  
  Angular 2 provides the mechanisms to do just this. Over the next sections
  we'll see how to build such a **structural component** that receives from the 
  outside a great deal of source material that it can manipulate and project 
  inside of himself.
  
  We'll focus on three main points:
  
  * How to projects elements in the component declaration
  
  * How to provide and use templates in a component
  
  * How to interact with components imperatively
  
.l-main-section  
:marked
  ## Heroes Dashboard
  
  Our example app is a dashboard from which we can get an overview of the status
  of both our HQ, and of our heroes.
  
figure.image-display
  img(src='/resources/images/devguide/structural-directives/dashboard-full.gif' alt="full dashboard")  

:marked
  Our dashboard will receive a representation of the HQ alerts from the component 
  DOM declaration, together with a list of heroes and a template of how to 
  represent a hero component.
  We'll also interact with these `hero-detail` components via the `Recall all heroes` button.
  
  A hero is a simple class with id, name and status.
  
  Our main application is `my-app`, which contains a list of heroes, an alert 
  and a function to update our alert. 
  In its template, we have a declaration of `hero-dashboard`.

  Our `hero-detail` component receives a hero to display and has a `recall()`
  method, that will note that hero as being recalled.
  
  We also have a [pipe](pipes) called `hero-detail-status-pipe` that will let us 
  filter an array of heroes by their status.
  
  And finally, we'll start with a barebones version of our `hero-dashboard`,
  that we'll fill in as we go.
      
.filetree
  .file angular2-hero-dashboard
  .children
    .file app
    .children
      .file app.component.html
      .file app.component.ts
      .file main.ts
      .file hero-dashboard.css
      .file hero-dashboard.component.html
      .file hero-dashboard.component.ts
      .file hero-detail.css
      .file hero-detail.component.ts
      .file hero-status.pipe.ts
    .file node_modules ...
    .file typings ...
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json  
        
:marked
  Here are all of the interesting files in this application.
+makeTabs(`
  structural-directives/ts/app/app.component.ts, 
  structural-directives/ts/app/app.component.html, 
  structural-directives/ts/app/hero.ts,
  structural-directives/ts/app/hero-dashboard.component.1.ts,
  structural-directives/ts/app/hero-dashboard.component.1.html,
  structural-directives/ts/app/hero-detail.component.ts,
  structural-directives/ts/app/hero-status.pipe.ts`,
  null, 
  `app.component.ts,
  app.component.html,
  hero.ts,
  hero-dashboard.component.ts,
  hero-dashboard.component.html,
  hero-detail.component.ts,
  hero-status.pipe.ts`)

:marked
  At this point we don't see much. We have a header, space for the HQ alerts,
  lanes for each hero status, and a button.
  
figure.image-display
  img(src='/resources/images/devguide/structural-directives/dashboard-empty.png' alt="empty dashboard")

:marked
  But first, let's dive a bit deeper into DOM.

.l-main-section  
:marked
  ## A tale of three DOMs
  
  We are used to seeing only one DOM - the one containing the elements in our layout. 
  In Angular we call this the "light" or the "view" DOM. 
  
  But now we see that with structural directives, a component's own template DOM may supersede this light DOM.
  What's the point of this?
  
  The answer lies in [Shadow Dom](http://webcomponents.org/polyfills/shadow-dom/),
  a part of the [Web Components Spec](http://w3c.github.io/webcomponents/spec/shadow/).
  Angular uses Shadow DOM emulation by default, but can be configured to either
  use a native browser Shadow DOM implementation, or to not use it at all.
  
  Shadow DOM lets Angular 2 encapsulate a components DOM. This is why styles
  we declare for a component don't leak out and affect other components.
  Everything is nice and tidy inside our components.
  
  According to the spec, we have can have a total of *three* DOM trees inside an
  element: **light DOM**, **shadow DOM** and **composed DOM**.
  
  **Light DOM** is what we see when *using* a component. It's what component
  consumers interact with, and how they can give component creators some DOM
  for them to use. In our previous example, this was the light DOM:
  
+makeExample('structural-directives/ts/app/my-component.component.html', 'my-component-3')(format=".")

:marked
  **Shadow DOM** is what we see when *creating* a component. It's what component
  creators interact with, and what they use to structure their components.
  Templates is where we keep our shadow DOM in angular.

+makeExample('structural-directives/ts/app/my-component.component.ts')(format=".")

:marked
  **Composed DOM** is what the browser ultimately renders, and thus what we see
  in the browser.
  
figure.image-display
  img(src='/resources/images/devguide/structural-directives/my-component-content.png' alt="my-component content")

:marked
  So when we talked about projection and using externally provided DOM inside
  our components, what we meant was that we were going to declare elements in 
  the *light DOM* and use them from within our *shadow DOM*, creating the 
  *composed DOM* that the browser will render. 
  
  The projected light DOM elements still remain in their original context as
  far as bindings are concerned - they are merely being *rendered* inside 
  another component. 
  
  This is important because they will still use their inputs and outputs from
  the component where they are *declared*, and not where they are *displayed*.
  
  Knowing this, how is projection related to the templates?
  It is true that the original template is in a components light DOM, but it's
  used as a 'inert' master copy from which instances are stamped out within the
  shadow DOM. 
  For this reason, these copies will use bindings found *within* the component
  instead of using the parent components bindings in the light DOM.
  
.l-main-section  
:marked
  ## Element projection
  
  Projection in Angular 2 is done via the `<ng-content>` component. It takes
  a CSS selector via the `select` attribute, which it'll use to choose which
  elements from the light DOM to project. 
  If we don't provide a selector, it will just use everything within the light DOM.
  
  In the case of our dashboard, we want to pull in the following element found
  in the parent component template:
  
+makeExample('structural-directives/ts/app/app.component.html', 'alert', 'app.component.html')(format=".")
  
:marked
  A simple way to select this element is via the `span.alert` selector. To slot
  it into our `hero-dashboard` template, all we have to do is add in an
  `ng-content` with that selector:

+makeExample('structural-directives/ts/app/hero-dashboard.component.html', 'ng-content-alert', 'hero-dashboard.component.html')(format=".")  

figure.image-display
  img(src='/resources/images/devguide/structural-directives/ng-content-alert.png' alt="ng-content projection alert")
  
:marked
  And here we have it! We should be mindful though: if our selector had picked
  up more than one element, `ng-content` would display them all one after the 
  other, in the order found in the light DOM.
  
  There's another important bit here: the click handler on alert. Our dashboard
  doesn't have any `updateAlert` method, yet...
  
figure.image-display
  img(src='/resources/images/devguide/structural-directives/projection-bindings.gif' alt="projection bindings")
    
:marked
  The binding still works! Its calling the method defined in our parent
  component, `AppComponent`.
  
+makeExample('structural-directives/ts/app/app.component.ts', 'alert', 'app.component.ts')(format=".")    

:marked
  This makes sense if we think about it. The alert is being *rendered* in
  our dashboard, but it still very much exists and is part of `AppComponent`.
  In fact, if it wasn't so, the initial alert text wouldn't appear either since
  it's a binding on `AppComponent` as well.

.l-main-section  
:marked
  ## Templates for components
  
  Our dashboard also takes in a template of how should heroes be rendered.
  Notice the `#hero` [local template variable](template-syntax.html#local-vars),
  it's going to be very relevant soon.

+makeExample('structural-directives/ts/app/app.component.html', 'template', 'app.component.html')(format=".")

:marked
  To reference this template from within our component we will use our familiar
  `TemplateRef` but this time we will not inject it in the constructor.
  
  Instead, we will use the `ContentChild` annotation. This annotation takes
  a component, finds the its **first** instance in the current components light 
  DOM, and binds it to the annotated variable.
  
+makeExample('structural-directives/ts/app/hero-dashboard.component.ts', 'content-child', 'hero-dashboard.component.js')(format=".")

:marked
  When trying to find `<template>` we have to use the `TemplateRef` as argument
  for the `ContentChild` annotation. This is because `<template>` is a very
  special core part of Angular 2 - not quite a standalone component, but rather 
  a fundamental part of the framework.
  
  If we wanted to find another component - say, `hero-detail` - we could query
  `@ContentChild(HeroDetailComponent) heroDetail: HeroDetailComponent;` instead.
  
  Doing this in our `HeroDashboardComponent` right now wouldn't give us anything
  though. Which is odd, since the the light DOM for `<hero-dashboard>` clearly
  has `<hero-detail [hero]="hero"></hero-detail>`.
  
  This ties back into templates - they are 'inert' as we saw 
  [before](#a-tale-of-three-doms). Their content is not instantiated, thus
  our light DOM does not contain any `<hero-detail>`, only a template.
  
  Now we have a hold of the template in `heroTmpl`. To render it, we will use
  a `ngFor` with a twist - we're going to give it a `TemplateRef` via the
  `[ngFor-template]` binding.
  
  This is also where the `#hero` that we saw earlier in the template comes into 
  play. `ngFor` will assign the current element to the template's local variable.
  
+makeExample('structural-directives/ts/app/hero-dashboard.component.html', 'ngFor-template', 'hero-dashboard.component.html')(format=".")

:marked
  This way we can stamp out in our dashboards shadow DOM copies of the template
  provided in its light DOM. Our dashboard never even knew what these look like!

figure.image-display
  img(src='/resources/images/devguide/structural-directives/ngFor-template.png' alt="ngFor-template")
  
.l-main-section  
:marked
  ## Components as first-class citizens
  
  At this point we're interacting with instantiated, 'living' components at 
  quite a high level. We can declare them, send them over to over to be rendered
  elsewhere and even use them as templates for other components content.
  
  The only thing missing is to talk to them directly. Our `HeroDetailComponent`
  has a `recall` method inside of it that we'd like to access:
  
+makeExample('structural-directives/ts/app/hero-detail.component.ts', 'recall', 'hero-detail.component.js')(format=".")

:marked
  We now have many `<hero-detail>` inside our dashboard, each with a different
  hero. Specifically, inside the shadow DOM.
  
  To get a hold of this list of `HeroDetailComponent`, we can use the 
  `@ViewChildren` annotation. There is a certain similarity between this 
  annotation and the similarly named one in the previous section.
  
  `@ContentChild` gives us the **first** component of a type inside the 
  **shadow DOM**, whereas `@ContentChildren` would give us a list of **all**
  of them.
  
  `@ViewChild` gives us the **first** component of a type inside the 
  **light DOM**, whereas `@ViewChildren` would give us a list of **all**
  of them.
  
  Lists given by `@ContentChildren` and `@ViewChildren` are of the `QueryList`
  type, and guaranteed to always contain the current, up to date components.
  
  Even though the `HeroDetail` component are declared in the template present in 
  the light DOM, our copies of it were stamped out *inside* the shadow DOM for
  `HeroDashboardComponent` by `ngFor`. Thus we must make use of `@ViewChildren` 
  instead of `@ContentChildren`.
  
  Having these components, we can now interact with them. Since they are just
  DOM elements we can simply access their properties and methods directly.
  
+makeExample('structural-directives/ts/app/hero-dashboard.component.ts', 'view-children', 'hero-dashboard.component.js')(format=".")

:marked
  Now when we click our button, the `recall` method will be called on all 
  `HeroDetail` components present inside the dashboard.
  
.l-main-section  
:marked
  ## Finished dashboard
  
  And thus, our dashboard component is now finished! It should function
  like shown initially:
  
figure.image-display
  img(src='/resources/images/devguide/structural-directives/dashboard-full.gif' alt="full dashboard")
+makeTabs(`
  structural-directives/ts/app/hero-dashboard.component.ts,
  structural-directives/ts/app/hero-dashboard.component.html`,
  null, 
  `hero-dashboard.component.ts,
  hero-dashboard.component.html`)

.l-main-section  
:marked
  ## Wrapping up
  
  That was a lot to take in! But we've finished this chapter richer for all
  we've learned. Let's recap:
  
  - We reviewed structural directives and the template tag
  - We wrote our own structural directive
  - We saw that components can share structure between themselves
  - We learned the about light and shadow DOM
  - We created a component that took projected light DOM content
  - We stamped out copies of a light DOM template
  - We interacted directly with components within our component
