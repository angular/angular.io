include ../../../../_includes/_util-fns

<!-- http://plnkr.co/edit/x9JYbC -->

:marked
  This chapter covers the following:
  * Building a simple attribute directive
  * Using an attribue directive in a template
  * Responding to events
  * Using binding to pass a parameter to the directive

:marked
  ## Directives overview
  
  There are three kinds of directives in Angular:
  * Components
  * Attribute directives
  * Structural directives (such as `*ng-if` and `*ng-for`)

  For most scenarios, building a component is all we need. After all, an Angular component
  is just a directive with a template.
  
  But there may be times we want to attach behavior to an HTML element without defining a template.
  That's the purpose of attribute directives.
  
  In this chapter, we'll build an attribute directive that changes the style of an element.
  We'll start with the simpliest attribute directive possible, and then add features to demonstrate
  the capabilities of attribute directives.

.l-main-section
:marked
  ## Building a simple attribute directive
  An attribute directive minimally requires a directive annotation that specifies a selector,
  and a controller class that implements the desired behavior.

  Let's build a small illustrative example together.

  Create a new project folder (`attribute-directives`) and follow the steps in the [QuickStart](../quickstart.html).
  
  To follow best practices, we'll create the attribute directive in a new file.
  Add a new file to the project and call it `highlight.directive.ts`.
  Add code to the file as shown:

+makeExample('attribute-directives/ts/src/app/highlight.directive.1.ts')

:marked
  First we import `Directive`, `ElementRef`, and `Renderer` from the Angular library.
  We'll use the `Directive` annotation to define this code as a directive.
  The `ElementRef` represents a location in the View and is used to 
  reference the element containing our attribute directive. 
  And `Renderer` provides features for modifying the user interface.
  
  Next, we define the `Directive` annotation. Minimally, the `Directive`
  annotation requires a selector. This is a CSS selector that selects
  elements from the DOM. 
  When building an attribute directive, the selector value is
  always defined within square brackets. This indicates that Angular should
  look for any elements containing an attribute with a name matching the selector.
  In this example, it will locate all elements
  that have an attribute named 'highlight'. 
  
  When the directive's selector matches an element in the DOM, Angular
  creates an instance of the directive's controller class, 
  injects the element reference and renderer,
  and executes the constructor.
  
  The directive's controller class contains the logic for our directive.
  Notice that we use the export keyword to export the controller class.
  This makes the class accessible to other components that want to use
  the attribute directive.
  
  So far our class only includes the constructor. The constructor uses the injected 
  element and changes the background color of that element to yellow. 
    
  There are several ways to modify the DOM properties from the controller class.
  * We can use the `nativeElement` property of the element reference that is injected into the controller.
  From this `nativeElement`, we can modify the DOM properties. Using this technique, we don't need
  to inject in the `Renderer`. However, we are then directly manipulating the DOM, which is not a
  recommended practice.
  * Alternatively, we can use the `Renderer` to set element properties. We are not then directly manipulating the
  DOM. This has the added advantage of working in multiple environments, such as within a Web Worker.

.l-main-section
:marked
  ## Using the attribute directive
  To use our new attribute directive, we modify the `app.ts` file by changing the template of the component.
  When we're done, it should look like this:

+makeExample('attribute-directives/ts/src/app/app.1.ts')

:marked
  First, we add an import to import the 'Highlight' component from our new file.

  Next we modify the template to use our new `highlight` attribute directive by
  simply adding `highlight` as an attribute on an element. In this example,
  we added it to a `span` element.
  
  Lastly, we add a `directives` field to the `Component` annotation to define
  the directives that we plan to use. Currently, we only want to use our `Highlight`
  directive.
  
  Running the application results in this:
  
figure.image-display
    img(src="/resources/images/devguide/attribute-directives/first-highlight.png" alt="First Highlight")

:marked
  Angular finds the `highlight` attribute on the `span` element and creates
  an instance of the `Highlight` class. The `span` element reference is injected into
  the constructor and our constructor code changes that element's background style to yellow.

.l-main-section
:marked
  ## Adding events

  We may want our directive to respond to events.
  For example, we may only want the text highlighted when the user
  moves the mouse over the element.
  
  We add two features to our code to respond to events:
  * We add the `host` field to the `Directive` annotation to
  define the events we will host.
  * We add methods in the controller class to response to the events.
  
  Here is the updated code:
  
+makeExample('attribute-directives/ts/src/app/highlight.directive.2.ts')
  
:marked
  For `host`, we define the events as key value pairs. The key is the event name enclosed in parentheses.
  The value defines the method responding to that event.
  
  In our example, the `(mouseEnter)` event calls the `onMouseEnter()` method 
  and the `(mouseleave)` event calls the `onMouseLeave()` method.

  Notice that we have changed the constructor parameter to include the `private` keyword.
  This defines `el` and `renderer` as local fields in the class. We can then use these fields
  anywhere within the class. 
  
  We also moved the code within the constructor to a separate private function called
  `_highlight`. This function takes in the color and sets the background color element style
  using that color.
  
  The `onMouseEnter()` method sets the background color of the element to yellow.
  The `onMouseLeave()` method clears the background color of the element.
  
  Running the application, you'll see the background color appear as you move the mouse over the `span` element.
  And you'll see the background color disappear as you move the mouse out of the `span` element.

.l-main-section
:marked
  ## Using binding

  Currently, the highlight color is hard-coded into our attribute directive.
  To make our directive more flexible, let's allow the user of our directive
  to specify the highlight color using Angular binding.
  
  Here is the updated directive:
  
+makeExample('attribute-directives/ts/src/app/highlight.directive.ts')

:marked
  First, we update the class to include a property for the bound value.
  In this case, we define a `colorName` property.
  
  Then we modify the `onMouseEnter()` method to use
  this color name property instead of the hard-coded color name.
  
  Lastly, we update the `Directive` annotation to include `inputs`.
  The `inputs` value is an array of key value pairs. The key is the
  name of the class property assigned by the binding. The value
  is the name of the attribute.
  
  Now we can use binding in the template to specify the color.
  Here is the updated `app.ts` file:

+makeExample('attribute-directives/ts/src/app/app.ts')

:marked
  We modify the template to add a binding. We bind the value of the highlight
  attribute to a variable that is defined in our `AppComponent`.
  
  Angular assigns the value from the binding to the `colorName` property of
  the directive's controller class. The `onMouseOver()` event handler uses this property
  to change the background color of the element.

.l-main-section
:marked
  ## Summary
  Now we know how to
  - build a simple **attribute directive** to attach behavior to an HTML element,
  - use that directive in a template,
  - respond to **events** to change behavior based on an event,
  - and use **binding** to pass a parameter to the attribute directive.

  Our final code:

+makeTabs('attribute-directives/ts/src/app/app.ts, '+
           'attribute-directives/ts/src/app/highlight.directive.ts',
           '',
           'app.ts, highlight.directive.ts')
