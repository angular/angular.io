block includes
  include ../_util-fns
:marked
  # Security
  Web application security has many aspects. This documentation describes Angular's built in
  protections against common web application vulnerabilities and attacks, such as Cross Site
  Scripting Attacks. It does not cover application level security, such as authentication (_Who is
  this user?_) or authorization (_What can this user do?_).

  The [Open Web Application Security Project (OWASP)](https://www.owasp.org/index.php/Category:OWASP_Guide_Project)
  has further information on the attacks and mitigations described below.

l-main-section
:marked
  # Table Of Contents

  * [Reporting vulnerabilities](#special-selectors)
  * [Follow best practices](#best-practices)
  * [Cross-site Scripting (XSS)](#xss)
  * [HTTP-level vulnerabilities](#http)
  * [Beware of *ElementRef* and *Renderer* Services](#element-ref)
  * [Hold regular security code reviews](#code-review)

p Try the #[+liveExampleLink2()] of the code shown in this chapter.

.l-main-section
h2#report-issues Reporting vulnerabilities
:marked
  Email us at [security@angularjs.org](mailto:security@angularjs.org) to report vulnerabilities in
  Angular itself.

  For further details on how Google handles security issues please refer to [Google's security
  philosophy](https://www.google.com/about/appsecurity/).

.l-main-section
h2#best-practices Best Practices (High Level)
:marked
  * **Keep current with the latest Angular library releases.**
  We regularly update our Angular libraries and these updates may fix security defects discovered in previous version.
  Check the Angular [change log](https://github.com/angular/angular/blob/master/CHANGELOG.md) for security-related updates.

  * **Don't modify your copy of Angular.**
  Private, customized versions of Angular tend to fall behind the current version and may neglect important
  security fixes and enhancements.
  Instead, share your Angular improvements with the community and make a pull request.

  <a id="offline-template-compiler"></a>
  * **Use the offline template compiler for production deployments.**
  The offline template compiler prevents a whole class of vulnerabilities called template injection, and also greatly
  improves application performance.

  * **Do not dynamically generate templates.** Constructing templates dynamically risks HTML template injection attacks,
  and prevents using the offline template compiler (see point above).

  * **Avoid Angular APIs marked in the documentation as “[_Security Risk_](#bypass-security-apis)”.**

  * **Avoid direct use of the DOM APIs**.
  The browser DOM APIs, for example `document`, but also the node available through `ElementRef` and many third party
  APIs such as jQuery, do not automatically protect your from security vulnerabilities. Prefer using Angular templates
  over interacting with the DOM programmatically.

  * **Set up a [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy)** on the server.
  A Content Security Policy is a [W3C Standard](https://w3c.github.io/webappsec-csp/)
  _defense-in-depth_ technique that helps identify and prevent common security attacks like [XSS](#xss).
  Modern browsers offer native support for CSP while older browsers simply ignore it.
  Enabling CSP involves configuring the web server to return the `Content-Security-Policy` HTTP header.
  Learn more at [Wikipedia](https://en.wikipedia.org/wiki/Content_Security_Policy)
  and [OWASP](https://www.owasp.org/index.php/Content_Security_Policy).

  * **Use a secure, auto-encoding template language on the server**.
  HTML constructed on the server is vulnerable to injection attacks. When generating server side
  HTML, e.g. for the initial page load of the Angular application, make sure to use a templating
  language that automatically encodes values to avoid [XSS](#xss) on the server.

.l-main-section
h2#code-review Hold Regular Security Code Reviews
:marked
  Require routine security code reviews, especially if the application touches sensitive information.

  Angular guards against most [XSS injection attacks](#xss) by default.
  There are a few, well-known APIs (discussed below) that lower those guards.
  Search the code base for the [_bypassSecurityTrust_](#bypass-security-apis) APIs and
  all references to [ElementRef](#element-ref) and  [Renderer](#element-ref).
  These are **red flags**.

  Automate the search and review process.

  Document every use of these APIs. Record what they do, why they are necessary, and who approved them.
  Pay attention when someone adds a new call to these APIs.
  Pay as much attention when someone removes a call to these APIs.

.l-main-section
h2#xss Prevent Cross-site Scripting (XSS)
:marked
  [Cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) enables attackers
  to inject malicious code into web pages. Such code can then for example steal user's data (in
  particular their login data), or perform actions impersonating the user. This is one of the most
  common attacks on the web.

  To block XSS attacks, we must prevent malicious code from entering the DOM. For example, if an
  attacker can trick us into inserting a `<script>` tag in the DOM, they can run arbitrary code on
  our website. The attack is not limited to `<script>` tags - many elements and properties in the
  DOM allow code execution, for example `<img onerror="...">`, `<a href="javascript:...">`. If
  attacker controlled data enters the DOM, we have to expect security vulnerabilities.

  ### Angular’s Cross-site Scripting Security Model

  To systematically block XSS bugs, Angular treats all values as untrusted by default. When a value
  is inserted into the DOM from a template, via property, attribute, style, or class binding, or via
  interpolation, Angular will sanitize and escape untrusted values.

  ### Sanitization and security contexts

  Sanitization inspects an untrusted value and turns it into a value that is safe to insert into
  the DOM. In many cases, values do not get changed by this at all. Sanitization depends on context
  - a value that is harmless in CSS is potentially dangerous in a URL.

  Angular defines four security contexts: HTML, style, URL, and resource URL.

  * HTML is used when interpreting a value as HTML, e.g. when binding to `innerHtml`
  * style is used when binding CSS into the `style` property
  * URL is used for URL properties such as `<a href>`
  * Resource URLs are URLs that will be loaded and executed as code, e.g. in `<script src>`

  Angular sanitizes untrusted values for the first three items; sanitizing resource URLs is not
  possible as they contain arbitrary code. In development mode, Angular prints a console warning
  when it has to change a value during sanitization.

  ### TODO binding/sanitization example

  need example that shows a value and also binds [innerHTML]. Users should maybe pass in
  values though a URL parameter, and put e.g. <script> into it, see it being stripped.

+makeExample('security/ts/app/inner-html-binding.component.ts', 'evil-title')(format=".")
+makeExample('security/ts/app/inner-html-binding.component.html', 'property-binding-vs-interpolation-sanitization')(format=".")
figure.image-display
  img(src='/resources/images/devguide/security/evil-title.png' alt="evil title made safe" width='500px')
:marked

.l-main-section
h2#bypass-security-apis Trusting safe values
:marked
  Sometimes applications genuinely need to include executable code, display an `<iframe>` from some
  URL, or construct potentially dangerous URLs. You can tell Angular that you inspected a value,
  checked how it is generated, and made sure it is always secure. But **be careful**! If you trust a
  value that can be malicious, you will likely introduce a security vulnerability into your
  application. If in doubt, find a professional security reviewer.

  You can mark a value as trusted by injecting `DomSanitizationService`, and calling one of the
  following methods.

  * `bypassSecurityTrustHtml`
  * `bypassSecurityTrustScript`
  * `bypassSecurityTrustStyle`
  * `bypassSecurityTrustUrl`
  * `bypassSecurityTrustResourceUrl`

  Remember, whether a value is safe depends on context, so you need to choose the right context for
  your intended use of the value.

+makeExample('security/ts/app/bypass-security.component.ts', 'evil-title')(format=".")
+makeExample('security/ts/app/bypass-security.component.html', 'property-binding-vs-interpolation-sanitization')(format=".")

:marked
  ### MARKER

.l-sub-section
  :marked
    Many applications require some kind of data-driven view generation in which the
    appearance of the page changes in response to data and metadata inputs.

    We can do that in Angular.
    See the [Dynamic Forms Cookbook](../cookbook/dynamic-form.html) for ideas in that direction.

    We can't do it by concatenating dangerous strings together or loading templates with embedded JavaScript.

.l-main-section
h2#http HTTP-level vulnerabilities
:marked
  Angular has built in support to help prevent two common HTTP vulnerabilities, Cross-site Request
  Forgery (XSRF) and Cross-site Script Inclusion (XSSI).

  In general:
  * encrypt information on the wire with SSL
  * configure [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)
  on servers so that application clients can make cross-domain web api calls safely
  * mitigate Cross-site Request Forgery (XSRF) attacks
  * mitigate Cross-site Script Inclusion (XSSI)

  Let's look briefly at how Angular assists in defense against XSRF and XSSI attacks

h3#xsrf Cross-site Request Forgery (XSRF)
:marked
  Cross-site Scripting (XSS) compromises the application itself. That threat must be blocked first.
  Yet even a site without XSS vulnerabilities may be threatened by other forms of attack.

  In a Cross-site Request Forgery (XSRF or CSRF), the attacker tricks the user into visiting a _different_ page, outside the application,
  while the user is still logged into the application elsewhere in the browser.

  For example, the user could be logged into a banking site and decide impulsively to look at a cute kitten picture.
  That kitten could disguise a malicious attempt to raid the user's bank account.

  The kitten page could forge silent requests to the server that mimic requests from the real application.
  The server honors those requests because it can't tell the difference between the real and hostile requests.
  The browser sent the same security cookie with both requests.

  The successful attacker can make any change that the user can make: transfer money, change a password, alter permissions, etc.

  An XSRF attack succeeds even when communications are encrypted by SSL.

  All of the mitigation techniques require action by the server.
  For example, the server might refuse all requests that lack a referrer header whose origin is on a whitelist ("strict referrer policy").
  The CORS `Access-Control-Origin` header can play a similar role in cross-origin requests.
  The client application is the passive beneficiary of these techniques.

  In another approach, the server sends the client a request validation token.
  The client must include that token in subsequent requests to that server.

  The Angular `http` client has built-in support for this technique in its customizable `XSRFStrategy`.
  The default `CookieXSRFStrategy` looks for a **secure** cookie called `'XSRF-TOKEN'` and sets
  an HTTP request header called `'X-XSRF-TOKEN'` with the value of that cookie as part of *every* request.
  It's the server's job to set and maintain the `'XSRF-TOKEN'` cookie.

  Learn about Cross Site Request Forgery (XSRF) at the Open Web Application Security Project (OWASP)
  [here](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) and
  [here](https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet).
  This [Stanford University paper](https://seclab.stanford.edu/websec/csrf/csrf.pdf) is a rich source of detail.

h3#xssi Cross-site Script Inclusion (XSSI)
:marked
  An attacker may include our application scripts in its exploit web page.
  If any of our scripts can access a user secret and the attacker can trick us into loading
  its trap page, we risk exposing those secrets to the attacker.
  This is one form of _Cross-site script inclusion (XSSI)_.

  **Don't bury secrets in JavaScript files!**

  That may seem obvious.
  But did you know that attackers can make requests for JSON data in the guise of script file requests?

code-example(format="." language="javascript").
  // Our api call pasted into a hostile script's src
  &lt;script src='https://my.com/api/customers'&gt;&lt;/script&gt;
:marked
  An attacker can read the data if the JSON response is executable!

  The server can thwart this attack by prefixing its JSON responses with `")]}',\n"`.
  That prefix prevents the browser from executing such a response within the attacker's script tags.

  We can still access this endpoint with Angular's `http` client.
  Angular looks for this `")]}',\n"` prefix in the response data and removes it
  before returning the real data to the caller.

  Learn more in the XSSI section of this
  [google web security post](https://security.googleblog.com/2011/05/website-security-for-webmasters.html)
