block includes
  include ../_util-fns
:marked
  # Security
  Web application security has many aspects. This documentation describes Angular's built in
  protections against common web application vulnerabilities and attacks, such as Cross Site
  Scripting Attacks. It does not cover application level security, such as authentication (_Who is
  this user?_) or authorization (_What can this user do?_).

  The [Open Web Application Security Project (OWASP)](https://www.owasp.org/index.php/Category:OWASP_Guide_Project)
  has further information on the attacks and mitigations described below.

l-main-section
:marked
  # Table Of Contents

  * [Reporting vulnerabilities](#special-selectors)
  * [Follow best practices](#best-practices)
  * [Cross-site Scripting (XSS)](#xss)
  * [HTTP-level vulnerabilities](#http)
  * [Beware of *ElementRef* and *Renderer* Services](#element-ref)
  * [Hold regular security code reviews](#code-review)

p Try the #[+liveExampleLink2()] of the code shown in this chapter.

.l-main-section
h2#report-issues Reporting vulnerabilities
:marked
  Email us at [security@angularjs.org](mailto:security@angularjs.org) to report vulnerabilities in
  Angular itself.

  For further details on how Google handles security issues please refer to [Google's security
  philosophy](https://www.google.com/about/appsecurity/).

.l-main-section
h2#best-practices Best Practices (High Level)
:marked
  * **Keep current with the latest Angular library releases.**
  We regularly update our Angular libraries and these updates may fix security defects discovered in previous version.
  Check the Angular [change log](https://github.com/angular/angular/blob/master/CHANGELOG.md) for security-related updates.

  * **Don't modify your copy of Angular.**
  Private, customized versions of Angular tend to fall behind the current version and may neglect important
  security fixes and enhancements.
  Instead, share your Angular improvements with the community and make a pull request.

  <a id="offline-template-compiler"></a>
  * **Use the offline template compiler for production deployments.**
  The offline template compiler prevents a whole class of vulnerabilities called template injection, and also greatly
  improves application performance.

  * **Do not dynamically generate templates.** Constructing templates dynamically risks HTML template injection attacks,
  and prevents using the offline template compiler (see point above).

  * **Avoid Angular APIs marked in the documentation as “[_Security Risk_](#bypass-security-apis)”.**

  * **Avoid direct use of the DOM APIs**.
  The browser DOM APIs, for example `document`, but also the node available through `ElementRef` and many third party
  APIs such as jQuery, do not automatically protect your from security vulnerabilities. Prefer using Angular templates
  over interacting with the DOM programmatically.

  * **Set up a [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy)** on the server.
  A Content Security Policy is a [W3C Standard](https://w3c.github.io/webappsec-csp/)
  _defense-in-depth_ technique that helps identify and prevent common security attacks like [XSS](#xss).
  Modern browsers offer native support for CSP while older browsers simply ignore it.
  Enabling CSP involves configuring the web server to return the `Content-Security-Policy` HTTP header.
  Learn more at [Wikipedia](https://en.wikipedia.org/wiki/Content_Security_Policy)
  and [OWASP](https://www.owasp.org/index.php/Content_Security_Policy).

  * **Use a secure, auto-encoding template language on the server**.
  HTML constructed on the server is vulnerable to injection attacks. When generating server side
  HTML, e.g. for the initial page load of the Angular application, make sure to use a templating
  language that automatically encodes values.

.l-main-section
h2#code-review Hold Regular Security Code Reviews
:marked
  Require routine security code reviews, especially if the application touches sensitive information.

  Angular guards against most [XSS injection attacks](#xss) by default.
  There are a few, well-known APIs (discussed below) that lower those guards.
  Search the code base for the [_bypassSecurityTrust_](#bypass-security-apis) APIs and
  all references to [ElementRef](#element-ref) and  [Renderer](#element-ref).
  These are **red flags**.

  Automate the search and review process.

  Document every use of these APIs. Record what they do, why they are necessary, and who approved them.
  Pay attention when someone adds a new call to these APIs.
  Pay as much attention when someone removes a call to these APIs.

.l-main-section
h2#xss Prevent Cross-site Scripting (XSS)
:marked
  [Cross-site scripting](https://en.wikipedia.org/wiki/Cross-site_scripting)
  enables attackers to inject their own malicious code into web pages.
  Such code can trick users into entering passwords or other sensitive information which it captures and sends
  to its own servers for subsequent exploitation.

  This is one of the most common attacks on the web.
  Fortunately, Angular protects us from most attacks ... unless we intentionally defeat those protections.

  ### Angular’s Cross-site Scripting Security Model

  To block XSS attacks, we must prevent malicious code from entering the DOM.
  If someone can trick us into displaying something between `<script>` tags, we're in serious trouble.

  Anything that updates the DOM is a potential point of attack and should be viewed with suspicion.
  Anything that updates the DOM with data from a server should be viewed with _extreme_ suspicion.

  #### Data Binding
  Angular data binding is a way to display server data in the DOM.

  Fortunately, Angular data binding is on alert for dangerous HTML.
  It **will not** allow HTML with script tags to leak into the browser, neither with interpolation
  nor property binding.

  Imagine a component property that had been set with the following malicious content,
  either retrieved from the server or entered by a user,
  and a template bound to that property with both _interpolation_ and _property bindings_.
+makeExample('content-security/ts/app/evil-binding.component.ts', 'evil-title')(format=".")

+makeExample('content-security/ts/app/evil-binding.component.html', 'property-binding-vs-interpolation-sanitization')(format=".")
:marked
  Interpolation handles the script tags differently than property binding but both approaches render the
  content harmlessly.
figure.image-display
  img(src='/resources/images/devguide/content-security/evil-title.png' alt="evil title made safe" width='500px')
:marked
  #### Avoid dynamic template html
  Angular relies on HTML templates to present data.
  We should do our best to ensure that the HTML templates we use come from a secure source and cannot be compromised.

  #### Use the Offline Template Compiler
  The safest approach is not to download the templates at all.
  Consider compiling the application with the [Offline Template Compiler](#offline-template-compiler).
  That compiler transforms templates to code that is _inlined_ with the component class.
  There is no template to download and the inline view code can't easily be tampered with.

  #### Angular scrubs templates
  Not everyone can or will use the _Offline Template Compiler_.
  What happens if a _bad guy_ sneaks some dangerous code into a downloaded template?

  Consider this component template:
+makeExample('content-security/ts/app/evil-template.component.html', null, 'app/evil-template.component.html')(format=".")
:marked
  We'd expect an alert box to pop up to tell us about evil doing.
  But Angular scrubs that script out of the template and displays pure happiness.

  This also means that we can't embed _any_ JavaScript in our HTML templates
  &mdash; not even "_good_" JavaScript.

  A determined developer might try to compose an _inline_ template dynamically out of strings
  that might come from anywhere.  Let's try doing that with some fixed strings imported from a file:

+makeExample('content-security/ts/app/strings.ts', null, 'app/strings.ts')(format=".")

+makeExample('content-security/ts/app/evil-string.component.ts', null, 'app/evil-string.component.ts')(format=".")
:marked
  We'd might again expect an alert box to pop up to tell us about more evil doing.
  But Angular scrubs that script out of the template too and life is beautiful once more.

  Angular does its best to steer us clear of the dangers of dynamic templates.

.l-sub-section
  :marked
    Many applications require some kind of data-driven view generation in which the
    appearance of the page changes in response to data and metadata inputs.

    We can do that in Angular.
    See the [Dynamic Forms Cookbook](../cookbook/dynamic-form.html) for ideas in that direction.

    We can't do it by concatenating dangerous strings together or loading templates with embedded JavaScript.

.l-main-section
h2#bypass-security-apis The <i>bypassSecurityTrust</i> APIs
:marked
  In the rare case where we need to disable Angular's automatic input sanitization,
  we may turn to the `bypassSecurityTrust` methods within the `DomSanitizationService`.
.callout.is-critical
  header Beware of the <i>bypassSecurityTrust</i> APIs
  :marked
    We are about to describe APIs that defeat Angular's automatic template and expression sanitization guards.
    These APIs are manifestly dangerous and should almost never be used.
    Be skeptical of all exceptions to this rule.
:marked
  The `DomSanitizationService`provides the following methods:

  * `bypassSecurityTrustHtml`
  * `bypassSecurityTrustScript`
  * `bypassSecurityTrustStyle`
  * `bypassSecurityTrustUrl`
  * `bypassSecurityTrustResourceUrl`

  Read the [Angular API guide](../api/platform-browser/index/DomSanitizationService-class.html)
  to learn what they do and why you _might_ use them.

  #### Review every usage
  The name _bypassSecurity_ is supposed to grab our attention.
  It cries out for a security review.
  Shame on us if we ignore the warning.

  <a id="review-dangerous-method"></a>
  What does it mean to do a review?
  1. Search the code base for the word _bypassSecurity_
  1. Demand an explanation and a justification for every usage
  1. Minimize the exposure by calling the method close to the data source.

  #### Call close to the data source
  We can't assess the risk unless we understand how data flow into the unsafe method.
  Where do the data come from? Can they be tampered with on their way to the unsafe method?

  Consider this example excerpt:
+makeExcerpt('content-security/ts/app/bypass-security.component.ts', 'distant-source', 'app/bypass-security.component.ts')
:marked
  We're bypassing Angular's sanitization of URLs and displaying an image that comes from ... where?
  Some service gets a url string from an unknown source.
  The `Observable` tells us that the url is likely to change during the user session for reasons unknown.

  We could find the service and vet it. But that's harder and
  this injected service could be replaced at runtime by an intermediate provider
  that we haven't verified. This code is difficult to review with any confidence.

  Compare it to this example:
+makeExcerpt('content-security/ts/app/bypass-security.component.ts', 'user-input', 'app/bypass-security.component.ts')
  Everything we need to review is in front of us.
  We can trace the source of unsafe data to a data-bound variable in this same file.
  We know how the data arrive.
  We locked down the base path so that only a portion of the URL is at risk (it is still a risk!).

  In sum, make this exceptional code easier to review by
  *keeping the source of unsafe data as close as possible to the unsafe method call*.

.l-main-section
h2#http HTTP-level vulnerabilities
:marked
  Angular has built in support to help prevent two common HTTP vulnerabilities, Cross-site Request
  Forgery (XSRF) and Cross-site Script Inclusion (XSSI).


  * encrypt information on the wire with SSL
  * configure [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)
  on servers so that application clients can make cross-domain web api calls safely
  * mitigate Cross-site Request Forgery (XSRF) attacks
  * mitigate Cross-site Script Inclusion (XSSI)

  Let's look briefly at how Angular assists in defense against XSRF and XSSI attacks

h3#xsrf Cross-site Request Forgery (XSRF)
:marked
  Cross-site Scripting (XSS) compromises the application itself. That threat must be blocked first.
  Yet even a site without XSS vulnerabilities may be threatened by other forms of attack.

  In a Cross-site Request Forgery (XSRF or CSRF), the attacker tricks the user into visiting a _different_ page, outside the application,
  while the user is still logged into the application elsewhere in the browser.

  For example, the user could be logged into a banking site and decide impulsively to look at a cute kitten picture.
  That kitten could disguise a malicious attempt to raid the user's bank account.

  The kitten page could forge silent requests to the server that mimic requests from the real application.
  The server honors those requests because it can't tell the difference between the real and hostile requests.
  The browser sent the same security cookie with both requests.

  The successful attacker can make any change that the user can make: transfer money, change a password, alter permissions, etc.

  An XSRF attack succeeds even when communications are encrypted by SSL.

  All of the mitigation techniques require action by the server.
  For example, the server might refuse all requests that lack a referrer header whose origin is on a whitelist ("strict referrer policy").
  The CORS `Access-Control-Origin` header can play a similar role in cross-origin requests.
  The client application is the passive beneficiary of these techniques.

  In another approach, the server sends the client a request validation token.
  The client must include that token in subsequent requests to that server.

  The Angular `http` client has built-in support for this technique in its customizable `XSRFStrategy`.
  The default `CookieXSRFStrategy` looks for a **secure** cookie called `'XSRF-TOKEN'` and sets
  an HTTP request header called `'X-XSRF-TOKEN'` with the value of that cookie as part of *every* request.
  It's the server's job to set and maintain the `'XSRF-TOKEN'` cookie.

  Learn about Cross Site Request Forgery (XSRF) at the Open Web Application Security Project (OWASP)
  [here](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) and
  [here](https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet).
  This [Stanford University paper](https://seclab.stanford.edu/websec/csrf/csrf.pdf) is a rich source of detail.

h3#xssi Cross-site Script Inclusion (XSSI)
:marked
  An attacker may include our application scripts in its exploit web page.
  If any of our scripts can access a user secret and the attacker can trick us into loading
  its trap page, we risk exposing those secrets to the attacker.
  This is one form of _Cross-site script inclusion (XSSI)_.

  **Don't bury secrets in JavaScript files!**

  That may seem obvious.
  But did you know that attackers can make requests for JSON data in the guise of script file requests?

code-example(format="." language="javascript").
  // Our api call pasted into a hostile script's src
  &lt;script src='https://my.com/api/customers'&gt;&lt;/script&gt;
:marked
  An attacker can read the data if the JSON response is executable!

  The server can thwart this attack by prefixing its JSON responses with `")]}',\n"`.
  That prefix prevents the browser from executing such a response within the attacker's script tags.

  We can still access this endpoint with Angular's `http` client.
  Angular looks for this `")]}',\n"` prefix in the response data and removes it
  before returning the real data to the caller.

  Learn more in the XSSI section of this
  [google web security post](https://security.googleblog.com/2011/05/website-security-for-webmasters.html)
