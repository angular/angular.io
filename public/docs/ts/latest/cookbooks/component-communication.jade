include ../../../../_includes/_util-fns

<a id="top"></a>
:marked
  In this chapter, we can find useful recipes for component communication scenarios.
  
.l-sub-section
  :marked
    For an in-depth look at each fundamental concepts in component communication, we can find detailed description and
    samples in the [Component Communication]() document.

.l-main-section
<a id="toc"></a>
:marked
  ## Table of contents
  
  [Pass data from parent to child with input binding](#parent-to-child)

  [Intercept input property changes with a setter](#parent-to-child-setter)

  [Intercept input property changes with *ngOnChanges*](#parent-to-child-on-changes)

  [Parent listens for child event](#child-to-parent)
  
  [Parent calls *ViewChild*](#parent-to-view-child)

  [Parent and children communicate via a service](#bidirectional-service)

// THESE TWO ARE TOO COMPLICATED AND DON'T PASS TESTS
  [Establish communication between unrelated components](#unrelated-service)

  [Obtain the content children of a parent component](#content-children)
:marked
  **See the [live example](/resources/live-examples/cb-component-communication/ts/plnkr.html)**.

.l-main-section
<a id="parent-to-child"></a>
:marked
  ## Pass data from parent to child with input binding
  
  `HeroChildComponent` has two ***input properties***, 
  typically adorned with [@Input decorations](docs/ts/latest/guide/template-syntax.html#inputs-outputs).
  
+makeExample('cb-component-communication/ts/app/hero-child.component.ts')
:marked
  The second `@Input` aliases the child component property name `masterName` as `'master'`.
  
  The `HeroParentComponent` nests the child `HeroChildComponent` inside an `*ngFor` repeater, 
  binding its `master` string property to the child's `master` alias
  and each iteration's `hero` instance to the child's `hero` property.

+makeExample('cb-component-communication/ts/app/hero-parent.component.ts')
:marked
  The running application displays three heroes:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/parent-to-child.png" alt="Parent-to-child")
  
:marked
  ### Test it
  
  E2E test that all children were instantiated and displayed as expected:
  
+makeExample('cb-component-communication/e2e-spec.js', 'parent-to-child')

:marked
  [Back to top](#top)

.l-main-section
<a id="parent-to-child-setter"></a>
:marked
  ## Intercept input property changes with a setter

  Use an input property setter to intercept and act upon a value from the parent.
  
  The setter of the `name` input property in the child `NameChildComponent` 
  trims the whitespace from a name and replaces an empty value with default text. 
  
+makeExample('cb-component-communication/ts/app/name-child.component.ts')

:marked
  Here's the `NameParentComponent` demonstrating name variations including a name with all spaces:

+makeExample('cb-component-communication/ts/app/name-parent.component.ts')

figure.image-display
  img(src="/resources/images/cookbooks/component-communication/setter.png" alt="Parent-to-child-setter")
  
:marked
  ### Test it

  E2E tests of input property setter with empty and non-empty names:
  
+makeExample('cb-component-communication/e2e-spec.js', 'parent-to-child-setter')

:marked
  [Back to top](#top)

.l-main-section
<a id="parent-to-child-on-changes"></a>
:marked
  ## Intercept input property changes with *ngOnChanges*

  Detect and act upon changes to input property values with the `ngOnChanges` method of the `OnChanges` lifecycle hook interface.
.l-sub-section
  :marked
    May prefer this approach to the property setter when watching multiple, interacting input properties.
    
    Learn about `ngOnChanges` in the [LifeCycle Hooks](../guide/lifecycle-hooks.html) chapter.
:marked
  This `VersionChildComponent` detects changes to the `major` and `minor` input properties and composes a log message reporting these changes:
  
+makeExample('cb-component-communication/ts/app/version-child.component.ts')

:marked
  The `VersionParentComponent` supplies the `minor` and `major` values and binds buttons to methods that change them.
  
+makeExample('cb-component-communication/ts/app/version-parent.component.ts')

:marked
  Here's the output of a button-pushing sequence:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/parent-to-child-on-changes.png" alt="Parent-to-child-onchanges")
  
:marked
  ### Test it
  
  Test that ***both*** input properties are set initially and that button clicks trigger 
  the expected `ngOnChanges` calls and values:
  
+makeExample('cb-component-communication/e2e-spec.js', 'parent-to-child-onchanges')

:marked
  [Back to top](#top)

.l-main-section
<a id="child-to-parent"></a>
:marked
  ## Parent listens for child event

  The child component exposes an `EventEmitter` property with which it `emits`events when something happens. 
  The parent binds to that event property and reacts to those events.
  
  The child's `EventEmitter` property is an ***output property***, 
    typically adorned with an [@Output decoration](docs/ts/latest/guide/template-syntax.html#inputs-outputs)
    as seen in this `VoterComponent`:
  
+makeExample('cb-component-communication/ts/app/voter.component.ts')

:marked
  Clicking a button triggers emission of a `true` or `false` (the boolean *payload*).
  
  The parent `VoteTakerComponent` binds an event handler (`onVoted`) that responds to the child event
  payload (`$event`) and updates a counter.
  
+makeExample('cb-component-communication/ts/app/votetaker.component.ts')

:marked
  The framework passes the event argument &mdash; represented by `$event` &mdash; to the handler method, 
  and the method processes it:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/child-to-parent.png" alt="Child-to-parent")
  
:marked
  ### Test it
  
  Test that clicking the *Agree* and *Disagree* buttons update the appropriate counters:
  
+makeExample('cb-component-communication/e2e-spec.js', 'child-to-parent')

:marked
  [Back to top](#top)

.l-main-section
<a id="parent-to-view-child"></a>
:marked
  ## Parent calls *ViewChild*
  A parent can call a child component once it has been located by a property adorned with a `@ViewChild` decorator property.
  
  This `CountdownTimerComponent` keeps counting down to zero and launching rockets.
  It has `start` and `stop` methods that control the countdown.
+makeExample('cb-component-communication/ts/app/countdown-timer.component.ts')
:marked
  The parent `CountdownParentComponent` cannot bind to the child's `start` and `stop` methods.
  But it can obtain a reference to the child component by applying a `@ViewChild` decorator 
  to a receiver property (`timerComponent`) after giving that decorator the type of component to find.
  Once it has that reference, it can access *any property or method* of the child component.
 
  Here it wires its own buttons to the child's start` and `stop`.

+makeExample('cb-component-communication/ts/app/countdown-parent.component.ts')
:marked

figure.image-display
  img(src="/resources/images/cookbooks/component-communication/countdown-timer-anim.gif" alt="countdown timer")
:marked
  ### Test it
  
  Test that clicking the *Stop* button pauses the countdown timer:
  
+makeExample('cb-component-communication/e2e-spec.js', 'parent-to-view-child')

:marked
  [Back to top](#top)

.l-main-section
<a id="bidirectional-service"></a>
:marked
  ## Parent and children communicate via a service

  A parent component and its children share a service whose interface enables bi-directional communication.

  The scope of the service instance is the parent component and its children. 
  Components outside this component subtree have no access to the service or their communications.
  
  This `MissionService` connects the `MissionControlComponent` to multiple `AstronautComponent` children.

+makeExample('cb-component-communication/ts/app/mission.service.ts')
.l-sub-section
  :marked
    The user of `EventEmitter` is a temporariy expedient. We should implement with `Observable.Subject` instead.
:marked
  The `MissionControlComponent` both provides the instance of the service that it shares with its children
  (through the `providers` metadata array) and injects that instance into itself through its constructor:
  
+makeExample('cb-component-communication/ts/app/missioncontrol.component.ts')

:marked
  The `AstronoutComponent` also injects the service in its constructor.
  Each `AstronoutComponent` is a child of the `MissionControlComponent` and therefore receives its parent's service instance:
  
+makeExample('cb-component-communication/ts/app/astronaut.component.ts')

:marked
  The *History* log demonstrates that messages travel in both directions between
  the parent `MissionControlComponent` and the `AstronoutComponent` children,
  facilitated by the service:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/bidirectional-service.png" alt="bidirectional-service")
  
:marked
  ### Test it
  
  Tests click buttons of both the parent `MissionControlComponent` and the `AstronoutComponent` children
  and verify that the *History* meets expectations:
  
+makeExample('cb-component-communication/e2e-spec.js', 'bidirectional-service')

:marked
  [Back to top](#top)




  
// BELOW HERE IS TOO COMPLICATED AND DOESN'T PASS TESTS !
  .l-main-section
  <a id="unrelated-service"></a>
  :marked
    ## Establish communication between unrelated components

    We can create services with properties and methods providing communication facilities, and inject the same 
    service instance into the communicating components. The sending party invokes service methods &mdash; or sets properties
    on the service instance &mdash;, the listening party subscribes to events representing messages.
    
    To begin, let's create a `MessageBus` component that simply relays any incoming messages to listening parties so that those
    can process the messages they are interested in. We also create and export an instance of `MessageBus` to serve as 
    the singleton instance to be injected into the communicating components:
    
  +makeExample('cb-component-communication/ts/app/messagebus.service.ts')

  :marked
    We create three communicating parties, _Telemetry Group_, _Trajectory Group_ and _Message Center_ that are totally unrelated
    to each other. They are independent groups within Command Center:
    
  +makeExample('cb-component-communication/ts/app/commandcenter-template.html')

  :marked
    For the sake of simplicity, all of these parties are represented by the same component type, `MissionGroup`.
    Each of them carries out actions, and listens to messages they are interested in. To ensure  they can communicate 
    with each other, we pass the `controlMessageBus` instance to all `MissionGroup` instance &mdash; using 
    the `provide()` method:
    
  +makeExample('cb-component-communication/ts/app/missiongroup.component.ts')

  :marked
    When we run the sample, we can see that messages are relayed among the components:

  figure.image-display
    img(src="/resources/images/cookbooks/component-communication/bidirectional-service.png" alt="bidirectional-service")
    
  :marked
    ### Test it
    
    We check that clicking the mission group action buttons of the app trigger the appropriate communication through the service:
    
  +makeExample('cb-component-communication/e2e-spec.js', 'unrelated-components')

  :marked
    [Back to top](#top)

  .l-main-section
  <a id="content-children"></a>
  :marked
    ## Obtain the content children of a parent component

    A parent component may have content children &mdash; components between its opening and closing tag. We can observe such
    a component in this template, `sequence-viewer`, which has a number of embedded `sequence-item` elements as its content:
    
  +makeExample('cb-component-communication/ts/app/sequence.component.html')

  :marked
    In the template of the `SequenceViewerComponent`, we cannot reference directly its content.
    For this purpose, we can use the `ContentChildren` annotation. As the definition of `SequenceViewerComponent` shows, we decorate 
    the `items` property (it has a type of `QueryList<SequenceItemComponent>`) with `ContentChildren`:
    
  +makeExample('cb-component-communication/ts/app/sequence-viewer.component.ts')

  :marked
    The `ContentChildren` annotation ensures that Angular automatically refreshes `items` whenever it detects that the
    the specified content of the parent changes. With defining the `ngAfterContentInit` lifecycle hook method, we can
    catch the event when `items` has been set. `Querylist` provides a `changes` property that we can use to subscribe
    to content changes.

  .l-sub-section
    :marked
      The API documentation of [ContentChildren](../api/core/ContentChildren-var.html) and 
      [QueryList](../api/core/QueryList-class.html) provide more details about these types.

  :marked
    The definition of `SequenceViewer` helps us understand the dinstinction between _content children_ and _view children_.
    Here, `SequenceViewer` can change its view children. When we click the **Limit to last 5 items** button, 
    the view displays only the last 5 sequence element. However, the content of `SequenceViewer` (the `sequence-item`
    elements between the opening and closing `sequence-viewer` tags) does not change after clicking the button.
    
    The content of `SequenceViewer` is managed by the `Sequence` component:
    
  +makeExample('cb-component-communication/ts/app/sequence.component.ts')

  :marked
    When we run this app, we can see that after clicking the **Limit to last 5 items** button, the `SequenceViewer`
    has 20 content children, but only 5 view children:
    
  figure.image-display
    img(src="/resources/images/cookbooks/component-communication/contentchildren.png" alt="contentchildren")
    
  :marked
    ### Test it
    
    We test that generating a few new sequence items works as expected, just like the **Show All** and
    **Limit to last 5 items** buttons.
    
  +makeExample('cb-component-communication/e2e-spec.js', 'contentchildren')

  :marked
    [Back to top](#top)
