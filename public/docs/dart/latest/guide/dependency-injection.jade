extends ../../../ts/latest/guide/dependency-injection.jade

block includes
  include ../_util-fns
  - var _thisDot = '';

block ctor-syntax
  .l-sub-section
    :marked
      We also leveraged Dart's constructor syntax for declaring parameters and
      initializing properties simultaneously.

block service-in-its-own-file
  //- N/A

block one-class-per-file-ts-tradeoffs
  //- N/A

block injectable-not-always-needed-in-ts
  //- The [Angular 2 Dart Transformer](https://github.com/angular/angular/wiki/Angular-2-Dart-Transformer)
  //- generates static code to replace the use of dart:mirrors. It requires that types be
  //- identified as targets for static code generation. Generally this is achieved
  //- by marking the class as @Injectable (though there are other mechanisms).

block ts-any-decorator-will-do
  //- N/A

block always-include-paren
  :marked
    Always write `@Injectable()`, not just `@Injectable`.
    A metadata annotation must be either a reference to a
    compile-time constant variable or a call to a constant
    constructor such as `Injectable()`.
    
    If we forget the parentheses, the analyzer will complain:
    "Annotation creation must have arguments". If we try to run the
    app anyway, it won't work, and the console will say
    "expression must be a compile-time constant".

block real-logger
  .l-sub-section
    :marked
      A real implementation would probably use the
      [logging package](https://pub.dartlang.org/packages/logging).

block optional-logger
  //- TBC.

block provider-function-etc
  //- N/A

block provider-ctor-args
  - var _secondParam = 'named parameter, such as <code>useClass</code>' 
  :marked
    We supply two arguments (or more) to the `Provider` constructor.

block dart-diff-const-metadata
  .callout.is-helpful
    header Dart difference: Constants in metadata
    :marked
      In Dart, the value of a metadata annotation must be a compile-time constant.
      For that reason, we can't call functions to get values
      to use within an annotation.
      Instead, we use constant literals or constant constructors.
      For example, a TypeScript program might use the
      function call `provide(Logger, {useClass: BetterLogger})`,
      which is equivalent to the TypeScript code
      `new Provider(Logger, {useClass: BetterLogger})`.
      A Dart annotation would instead use the constant value `const Provider(Logger, useClass: BetterLogger)`.

block dart-diff-const-metadata-ctor
  .callout.is-helpful
    header Dart difference: Constants in metadata
    :marked
      Because Dart annotations must be compile-time constants,
      `useValue` is often used with string or list literals.
      However, `useValue` works with any constant object.

      To create a class that can provide constant objects,
      ensure all its instance variables are `final`,
      and give it a `const` constructor.
      
      Create a constant instance of the class by using `const` instead of `new`.

// - var stylePattern = { otl: /(useValue.*\))/gm };
// +makeExample('dependency-injection/dart/lib/providers_component.dart','providers-9','', stylePattern)(format='.')

block non-class-dep-eg
  span string, list, map, or maybe a function.

block config-obj-maps
  | . They can be 
  | <b><a href="https://api.dartlang.org/stable/dart-core/Map-class.html">Map</a></b>
  | literals

block what-should-we-use-as-token
  :marked
    But what should we use as the token?
    We could use the **[Map][]** interface.

    [Map]: https://api.dartlang.org/stable/dart-core/Map-class.html

  .callout.is-helpful
    header Dart difference: Interfaces are valid tokens
    :marked
      In TypeScript, interfaces don't work as provider tokens.
      Dart doesn't have this limitation;
      every class implicitly defines an interface,
      so interface names are just class names.

  :marked
    The problem with using `Map` as a token, is not that it is an abstract
    class, but rather that it is very general purpose (like `String`) and so
    our application may depend on several maps each used for a
    different purpose.

block dart-map-alternative
  :marked
    As an alternative to using a configuration `Map`, we can define
    a custom class type:

  +makeExample('dependency-injection/ts/app/app.config.ts','config-alt','app/app-config.ts (alternative config)')(format='.')

  :marked
    One of the key benefits of defining a configuration object class, is
    strong static checking relative to configuration property names and their types.
    The Dart [cascade operator][cascade-op] provides a convenient means of initializing
    the configuration object. Use of the cascaded object initialization idiom
    prevents us from defining our configuration object instance as `const`. 
    As a consequencem we cannot declare a [value provider](#value-provider),
    but a [factory provider](#factory-provider) does the trick &mdash; as
    we illustrate by providing and injecting the configuration object in our
    top-level `AppComponent`:

    [cascade-op]: https://www.dartlang.org/docs/dart-up-and-running/ch02.html#cascade

  +makeExcerpt('lib/app_component.dart','providers')
  +makeExcerpt('lib/app_component.dart','ctor')
